// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.sdwan;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.sdwan.inputs.DnsSecurityPolicyTargetVpnArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DnsSecurityPolicyArgs extends com.pulumi.resources.ResourceArgs {

    public static final DnsSecurityPolicyArgs Empty = new DnsSecurityPolicyArgs();

    /**
     * String that is a number that corresponds to Umbrella Multi Org, can be empty if not using Umbrella Multi Org
     * 
     */
    @Import(name="childOrgId", required=true)
    private Output<String> childOrgId;

    /**
     * @return String that is a number that corresponds to Umbrella Multi Org, can be empty if not using Umbrella Multi Org
     * 
     */
    public Output<String> childOrgId() {
        return this.childOrgId;
    }

    /**
     * The description of the Policy
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the Policy
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * If matchAllVpn is false, this field is only true if at least one of the targetVpns entires contains an umbrellaDefault true
     * 
     */
    @Import(name="dnsCrypt", required=true)
    private Output<Boolean> dnsCrypt;

    /**
     * @return If matchAllVpn is false, this field is only true if at least one of the targetVpns entires contains an umbrellaDefault true
     * 
     */
    public Output<Boolean> dnsCrypt() {
        return this.dnsCrypt;
    }

    /**
     * Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry, Attribute conditional on `match_all_vpn` being equal to `true`
     * 
     */
    @Import(name="dnsServerIp", required=true)
    private Output<String> dnsServerIp;

    /**
     * @return Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry, Attribute conditional on `match_all_vpn` being equal to `true`
     * 
     */
    public Output<String> dnsServerIp() {
        return this.dnsServerIp;
    }

    /**
     * Feature Profile ID
     * 
     */
    @Import(name="featureProfileId", required=true)
    private Output<String> featureProfileId;

    /**
     * @return Feature Profile ID
     * 
     */
    public Output<String> featureProfileId() {
        return this.featureProfileId;
    }

    /**
     * Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
     * 
     */
    @Import(name="localDomainBypassEnabled", required=true)
    private Output<Boolean> localDomainBypassEnabled;

    /**
     * @return Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
     * 
     */
    public Output<Boolean> localDomainBypassEnabled() {
        return this.localDomainBypassEnabled;
    }

    @Import(name="localDomainBypassListId", required=true)
    private Output<String> localDomainBypassListId;

    public Output<String> localDomainBypassListId() {
        return this.localDomainBypassListId;
    }

    /**
     * If this is true, there shouldn&#39;t be a targetVpns field, if false then targetVpns field should be there
     * 
     */
    @Import(name="matchAllVpn", required=true)
    private Output<Boolean> matchAllVpn;

    /**
     * @return If this is true, there shouldn&#39;t be a targetVpns field, if false then targetVpns field should be there
     * 
     */
    public Output<Boolean> matchAllVpn() {
        return this.matchAllVpn;
    }

    /**
     * The name of the Policy
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the Policy
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Will be under data field only if matchAllVpn is false, if matchAllVpn is true field should not be in payload, Attribute conditional on `match_all_vpn` being equal to `false`
     * 
     */
    @Import(name="targetVpns")
    private @Nullable Output<List<DnsSecurityPolicyTargetVpnArgs>> targetVpns;

    /**
     * @return Will be under data field only if matchAllVpn is false, if matchAllVpn is true field should not be in payload, Attribute conditional on `match_all_vpn` being equal to `false`
     * 
     */
    public Optional<Output<List<DnsSecurityPolicyTargetVpnArgs>>> targetVpns() {
        return Optional.ofNullable(this.targetVpns);
    }

    /**
     * Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
     * 
     */
    @Import(name="umbrellaDefault", required=true)
    private Output<Boolean> umbrellaDefault;

    /**
     * @return Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
     * 
     */
    public Output<Boolean> umbrellaDefault() {
        return this.umbrellaDefault;
    }

    private DnsSecurityPolicyArgs() {}

    private DnsSecurityPolicyArgs(DnsSecurityPolicyArgs $) {
        this.childOrgId = $.childOrgId;
        this.description = $.description;
        this.dnsCrypt = $.dnsCrypt;
        this.dnsServerIp = $.dnsServerIp;
        this.featureProfileId = $.featureProfileId;
        this.localDomainBypassEnabled = $.localDomainBypassEnabled;
        this.localDomainBypassListId = $.localDomainBypassListId;
        this.matchAllVpn = $.matchAllVpn;
        this.name = $.name;
        this.targetVpns = $.targetVpns;
        this.umbrellaDefault = $.umbrellaDefault;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DnsSecurityPolicyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DnsSecurityPolicyArgs $;

        public Builder() {
            $ = new DnsSecurityPolicyArgs();
        }

        public Builder(DnsSecurityPolicyArgs defaults) {
            $ = new DnsSecurityPolicyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param childOrgId String that is a number that corresponds to Umbrella Multi Org, can be empty if not using Umbrella Multi Org
         * 
         * @return builder
         * 
         */
        public Builder childOrgId(Output<String> childOrgId) {
            $.childOrgId = childOrgId;
            return this;
        }

        /**
         * @param childOrgId String that is a number that corresponds to Umbrella Multi Org, can be empty if not using Umbrella Multi Org
         * 
         * @return builder
         * 
         */
        public Builder childOrgId(String childOrgId) {
            return childOrgId(Output.of(childOrgId));
        }

        /**
         * @param description The description of the Policy
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the Policy
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param dnsCrypt If matchAllVpn is false, this field is only true if at least one of the targetVpns entires contains an umbrellaDefault true
         * 
         * @return builder
         * 
         */
        public Builder dnsCrypt(Output<Boolean> dnsCrypt) {
            $.dnsCrypt = dnsCrypt;
            return this;
        }

        /**
         * @param dnsCrypt If matchAllVpn is false, this field is only true if at least one of the targetVpns entires contains an umbrellaDefault true
         * 
         * @return builder
         * 
         */
        public Builder dnsCrypt(Boolean dnsCrypt) {
            return dnsCrypt(Output.of(dnsCrypt));
        }

        /**
         * @param dnsServerIp Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry, Attribute conditional on `match_all_vpn` being equal to `true`
         * 
         * @return builder
         * 
         */
        public Builder dnsServerIp(Output<String> dnsServerIp) {
            $.dnsServerIp = dnsServerIp;
            return this;
        }

        /**
         * @param dnsServerIp Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry, Attribute conditional on `match_all_vpn` being equal to `true`
         * 
         * @return builder
         * 
         */
        public Builder dnsServerIp(String dnsServerIp) {
            return dnsServerIp(Output.of(dnsServerIp));
        }

        /**
         * @param featureProfileId Feature Profile ID
         * 
         * @return builder
         * 
         */
        public Builder featureProfileId(Output<String> featureProfileId) {
            $.featureProfileId = featureProfileId;
            return this;
        }

        /**
         * @param featureProfileId Feature Profile ID
         * 
         * @return builder
         * 
         */
        public Builder featureProfileId(String featureProfileId) {
            return featureProfileId(Output.of(featureProfileId));
        }

        /**
         * @param localDomainBypassEnabled Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
         * 
         * @return builder
         * 
         */
        public Builder localDomainBypassEnabled(Output<Boolean> localDomainBypassEnabled) {
            $.localDomainBypassEnabled = localDomainBypassEnabled;
            return this;
        }

        /**
         * @param localDomainBypassEnabled Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
         * 
         * @return builder
         * 
         */
        public Builder localDomainBypassEnabled(Boolean localDomainBypassEnabled) {
            return localDomainBypassEnabled(Output.of(localDomainBypassEnabled));
        }

        public Builder localDomainBypassListId(Output<String> localDomainBypassListId) {
            $.localDomainBypassListId = localDomainBypassListId;
            return this;
        }

        public Builder localDomainBypassListId(String localDomainBypassListId) {
            return localDomainBypassListId(Output.of(localDomainBypassListId));
        }

        /**
         * @param matchAllVpn If this is true, there shouldn&#39;t be a targetVpns field, if false then targetVpns field should be there
         * 
         * @return builder
         * 
         */
        public Builder matchAllVpn(Output<Boolean> matchAllVpn) {
            $.matchAllVpn = matchAllVpn;
            return this;
        }

        /**
         * @param matchAllVpn If this is true, there shouldn&#39;t be a targetVpns field, if false then targetVpns field should be there
         * 
         * @return builder
         * 
         */
        public Builder matchAllVpn(Boolean matchAllVpn) {
            return matchAllVpn(Output.of(matchAllVpn));
        }

        /**
         * @param name The name of the Policy
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the Policy
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param targetVpns Will be under data field only if matchAllVpn is false, if matchAllVpn is true field should not be in payload, Attribute conditional on `match_all_vpn` being equal to `false`
         * 
         * @return builder
         * 
         */
        public Builder targetVpns(@Nullable Output<List<DnsSecurityPolicyTargetVpnArgs>> targetVpns) {
            $.targetVpns = targetVpns;
            return this;
        }

        /**
         * @param targetVpns Will be under data field only if matchAllVpn is false, if matchAllVpn is true field should not be in payload, Attribute conditional on `match_all_vpn` being equal to `false`
         * 
         * @return builder
         * 
         */
        public Builder targetVpns(List<DnsSecurityPolicyTargetVpnArgs> targetVpns) {
            return targetVpns(Output.of(targetVpns));
        }

        /**
         * @param targetVpns Will be under data field only if matchAllVpn is false, if matchAllVpn is true field should not be in payload, Attribute conditional on `match_all_vpn` being equal to `false`
         * 
         * @return builder
         * 
         */
        public Builder targetVpns(DnsSecurityPolicyTargetVpnArgs... targetVpns) {
            return targetVpns(List.of(targetVpns));
        }

        /**
         * @param umbrellaDefault Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
         * 
         * @return builder
         * 
         */
        public Builder umbrellaDefault(Output<Boolean> umbrellaDefault) {
            $.umbrellaDefault = umbrellaDefault;
            return this;
        }

        /**
         * @param umbrellaDefault Field will only be under data field if matchAllVpn is true, otherwise field will be under targetVpns and set per entry
         * 
         * @return builder
         * 
         */
        public Builder umbrellaDefault(Boolean umbrellaDefault) {
            return umbrellaDefault(Output.of(umbrellaDefault));
        }

        public DnsSecurityPolicyArgs build() {
            if ($.childOrgId == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "childOrgId");
            }
            if ($.dnsCrypt == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "dnsCrypt");
            }
            if ($.dnsServerIp == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "dnsServerIp");
            }
            if ($.featureProfileId == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "featureProfileId");
            }
            if ($.localDomainBypassEnabled == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "localDomainBypassEnabled");
            }
            if ($.localDomainBypassListId == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "localDomainBypassListId");
            }
            if ($.matchAllVpn == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "matchAllVpn");
            }
            if ($.umbrellaDefault == null) {
                throw new MissingRequiredPropertyException("DnsSecurityPolicyArgs", "umbrellaDefault");
            }
            return $;
        }
    }

}
