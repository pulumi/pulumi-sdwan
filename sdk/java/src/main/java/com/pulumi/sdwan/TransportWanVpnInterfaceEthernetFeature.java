// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.sdwan;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.sdwan.TransportWanVpnInterfaceEthernetFeatureArgs;
import com.pulumi.sdwan.Utilities;
import com.pulumi.sdwan.inputs.TransportWanVpnInterfaceEthernetFeatureState;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureArp;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureIpv4SecondaryAddress;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureIpv6SecondaryAddress;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureNewStaticNat;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureStaticNat66;
import com.pulumi.sdwan.outputs.TransportWanVpnInterfaceEthernetFeatureTunnelInterfaceEncapsulation;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * This resource can manage a Transport WAN VPN Interface Ethernet Feature.
 *   - Minimum SD-WAN Manager version: `20.12.0`
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.sdwan.TransportWanVpnInterfaceEthernetFeature;
 * import com.pulumi.sdwan.TransportWanVpnInterfaceEthernetFeatureArgs;
 * import com.pulumi.sdwan.inputs.TransportWanVpnInterfaceEthernetFeatureIpv4SecondaryAddressArgs;
 * import com.pulumi.sdwan.inputs.TransportWanVpnInterfaceEthernetFeatureTunnelInterfaceEncapsulationArgs;
 * import com.pulumi.sdwan.inputs.TransportWanVpnInterfaceEthernetFeatureNewStaticNatArgs;
 * import com.pulumi.sdwan.inputs.TransportWanVpnInterfaceEthernetFeatureStaticNat66Args;
 * import com.pulumi.sdwan.inputs.TransportWanVpnInterfaceEthernetFeatureArpArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new TransportWanVpnInterfaceEthernetFeature("example", TransportWanVpnInterfaceEthernetFeatureArgs.builder()
 *             .name("Example")
 *             .description("My Example")
 *             .featureProfileId("f6dd22c8-0b4f-496c-9a0b-6813d1f8b8ac")
 *             .transportWanVpnFeatureId("140331f6-5418-4755-a059-13c77eb96037")
 *             .shutdown(true)
 *             .interfaceName("GigabitEthernet1")
 *             .interfaceDescription("WAN")
 *             .ipv4ConfigurationType("static")
 *             .ipv4Address("1.2.3.4")
 *             .ipv4SubnetMask("0.0.0.0")
 *             .ipv4SecondaryAddresses(TransportWanVpnInterfaceEthernetFeatureIpv4SecondaryAddressArgs.builder()
 *                 .address("1.2.3.4")
 *                 .subnetMask("0.0.0.0")
 *                 .build())
 *             .ipv4DhcpHelpers("1.2.3.4")
 *             .ipv6ConfigurationType("static")
 *             .iperfServer("example")
 *             .blockNonSourceIp(false)
 *             .serviceProvider("example")
 *             .bandwidthUpstream(21474836)
 *             .bandwidthDownstream(21474836)
 *             .autoDetectBandwidth(false)
 *             .tunnelInterface(true)
 *             .perTunnelQos(true)
 *             .tunnelQosMode("hub")
 *             .tunnelBandwidthPercent(82)
 *             .tunnelInterfaceBindLoopbackTunnel("example")
 *             .tunnelInterfaceCarrier("default")
 *             .tunnelInterfaceColor("default")
 *             .tunnelInterfaceHelloInterval(1000)
 *             .tunnelInterfaceHelloTolerance(12)
 *             .tunnelInterfaceLastResortCircuit(false)
 *             .tunnelInterfaceGreTunnelDestinationIp("1.2.3.4")
 *             .tunnelInterfaceColorRestrict(true)
 *             .tunnelInterfaceGroups(42949672)
 *             .tunnelInterfaceBorder(false)
 *             .tunnelInterfaceMaxControlConnections(62)
 *             .tunnelInterfaceNatRefreshInterval(5)
 *             .tunnelInterfaceVbondAsStunServer(false)
 *             .tunnelInterfaceExcludeControllerGroupLists(2)
 *             .tunnelInterfaceVmanageConnectionPreference(8)
 *             .tunnelInterfacePortHop(true)
 *             .tunnelInterfaceLowBandwidthLink(false)
 *             .tunnelInterfaceTunnelTcpMss(1460)
 *             .tunnelInterfaceClearDontFragment(false)
 *             .tunnelInterfaceCtsSgtPropagation(false)
 *             .tunnelInterfaceNetworkBroadcast(false)
 *             .tunnelInterfaceAllowAll(false)
 *             .tunnelInterfaceAllowBgp(false)
 *             .tunnelInterfaceAllowDhcp(true)
 *             .tunnelInterfaceAllowNtp(false)
 *             .tunnelInterfaceAllowSsh(false)
 *             .tunnelInterfaceAllowDns(true)
 *             .tunnelInterfaceAllowIcmp(true)
 *             .tunnelInterfaceAllowHttps(true)
 *             .tunnelInterfaceAllowOspf(false)
 *             .tunnelInterfaceAllowStun(false)
 *             .tunnelInterfaceAllowSnmp(false)
 *             .tunnelInterfaceAllowNetconf(false)
 *             .tunnelInterfaceAllowBfd(false)
 *             .tunnelInterfaceEncapsulations(TransportWanVpnInterfaceEthernetFeatureTunnelInterfaceEncapsulationArgs.builder()
 *                 .encapsulation("gre")
 *                 .preference(4294967)
 *                 .weight(250)
 *                 .build())
 *             .natIpv4(true)
 *             .natType("interface")
 *             .natUdpTimeout(1)
 *             .natTcpTimeout(60)
 *             .newStaticNats(TransportWanVpnInterfaceEthernetFeatureNewStaticNatArgs.builder()
 *                 .sourceIp("1.2.3.4")
 *                 .translatedIp("2.3.4.5")
 *                 .direction("inside")
 *                 .sourceVpn(3)
 *                 .build())
 *             .natIpv6(true)
 *             .nat64(false)
 *             .nat66(true)
 *             .staticNat66s(TransportWanVpnInterfaceEthernetFeatureStaticNat66Args.builder()
 *                 .sourcePrefix("2001:0db8:85a3::/48")
 *                 .translatedSourcePrefix("abcd:1234:5678::/48")
 *                 .sourceVpnId(4)
 *                 .build())
 *             .qosAdaptive(false)
 *             .qosShapingRate(16)
 *             .aclIpv4EgressFeatureId("f6dd22c8-0b4f-496c-9a0b-6813d1f8b8ac")
 *             .aclIpv6IngressFeatureId("f6dd22c8-0b4f-496c-9a0b-6813d1f8b8ac")
 *             .arps(TransportWanVpnInterfaceEthernetFeatureArpArgs.builder()
 *                 .ipAddress("1.2.3.4")
 *                 .macAddress("00-B0-D0-63-C2-26")
 *                 .build())
 *             .icmpRedirectDisable(true)
 *             .duplex("full")
 *             .macAddress("00-B0-D0-63-C2-26")
 *             .ipMtu(1500)
 *             .interfaceMtu(1500)
 *             .tcpMss(505)
 *             .speed("2500")
 *             .arpTimeout(1200)
 *             .autonegotiate(false)
 *             .mediaType("rj45")
 *             .tlocExtension("tloc")
 *             .greTunnelSourceIp("1.2.3.4")
 *             .xconnect("example")
 *             .loadInterval(30)
 *             .tracker("example")
 *             .ipDirectedBroadcast(false)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * The `pulumi import` command can be used, for example:
 * 
 * Expected import identifier with the format: &#34;transport_wan_vpn_interface_ethernet_feature_id,feature_profile_id,transport_wan_vpn_feature_id&#34;
 * 
 * ```sh
 * $ pulumi import sdwan:index/transportWanVpnInterfaceEthernetFeature:TransportWanVpnInterfaceEthernetFeature example &#34;f6b2c44c-693c-4763-b010-895aa3d236bd,f6dd22c8-0b4f-496c-9a0b-6813d1f8b8ac,140331f6-5418-4755-a059-13c77eb96037&#34;
 * ```
 * 
 */
@ResourceType(type="sdwan:index/transportWanVpnInterfaceEthernetFeature:TransportWanVpnInterfaceEthernetFeature")
public class TransportWanVpnInterfaceEthernetFeature extends com.pulumi.resources.CustomResource {
    @Export(name="aclIpv4EgressFeatureId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv4EgressFeatureId;

    public Output<Optional<String>> aclIpv4EgressFeatureId() {
        return Codegen.optional(this.aclIpv4EgressFeatureId);
    }
    @Export(name="aclIpv4IngressFeatureId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv4IngressFeatureId;

    public Output<Optional<String>> aclIpv4IngressFeatureId() {
        return Codegen.optional(this.aclIpv4IngressFeatureId);
    }
    @Export(name="aclIpv6EgressFeatureId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv6EgressFeatureId;

    public Output<Optional<String>> aclIpv6EgressFeatureId() {
        return Codegen.optional(this.aclIpv6EgressFeatureId);
    }
    @Export(name="aclIpv6IngressFeatureId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv6IngressFeatureId;

    public Output<Optional<String>> aclIpv6IngressFeatureId() {
        return Codegen.optional(this.aclIpv6IngressFeatureId);
    }
    /**
     * Timeout value for dynamically learned ARP entries, &lt;0..2678400&gt; seconds
     *   - Range: `0`-`2147483`
     *   - Default value: `1200`
     * 
     */
    @Export(name="arpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> arpTimeout;

    /**
     * @return Timeout value for dynamically learned ARP entries, &lt;0..2678400&gt; seconds
     *   - Range: `0`-`2147483`
     *   - Default value: `1200`
     * 
     */
    public Output<Optional<Integer>> arpTimeout() {
        return Codegen.optional(this.arpTimeout);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="arpTimeoutVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> arpTimeoutVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> arpTimeoutVariable() {
        return Codegen.optional(this.arpTimeoutVariable);
    }
    /**
     * Configure ARP entries
     * 
     */
    @Export(name="arps", refs={List.class,TransportWanVpnInterfaceEthernetFeatureArp.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureArp>> arps;

    /**
     * @return Configure ARP entries
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureArp>>> arps() {
        return Codegen.optional(this.arps);
    }
    /**
     * Interface auto detect bandwidth
     *   - Default value: `false`
     * 
     */
    @Export(name="autoDetectBandwidth", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> autoDetectBandwidth;

    /**
     * @return Interface auto detect bandwidth
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> autoDetectBandwidth() {
        return Codegen.optional(this.autoDetectBandwidth);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="autoDetectBandwidthVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> autoDetectBandwidthVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> autoDetectBandwidthVariable() {
        return Codegen.optional(this.autoDetectBandwidthVariable);
    }
    /**
     * Link autonegotiation
     * 
     */
    @Export(name="autonegotiate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> autonegotiate;

    /**
     * @return Link autonegotiation
     * 
     */
    public Output<Optional<Boolean>> autonegotiate() {
        return Codegen.optional(this.autonegotiate);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="autonegotiateVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> autonegotiateVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> autonegotiateVariable() {
        return Codegen.optional(this.autonegotiateVariable);
    }
    /**
     * Interface downstream bandwidth capacity, in kbps
     *   - Range: `1`-`2147483647`
     * 
     */
    @Export(name="bandwidthDownstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> bandwidthDownstream;

    /**
     * @return Interface downstream bandwidth capacity, in kbps
     *   - Range: `1`-`2147483647`
     * 
     */
    public Output<Optional<Integer>> bandwidthDownstream() {
        return Codegen.optional(this.bandwidthDownstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="bandwidthDownstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> bandwidthDownstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> bandwidthDownstreamVariable() {
        return Codegen.optional(this.bandwidthDownstreamVariable);
    }
    /**
     * Interface upstream bandwidth capacity, in kbps
     *   - Range: `1`-`2147483647`
     * 
     */
    @Export(name="bandwidthUpstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> bandwidthUpstream;

    /**
     * @return Interface upstream bandwidth capacity, in kbps
     *   - Range: `1`-`2147483647`
     * 
     */
    public Output<Optional<Integer>> bandwidthUpstream() {
        return Codegen.optional(this.bandwidthUpstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="bandwidthUpstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> bandwidthUpstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> bandwidthUpstreamVariable() {
        return Codegen.optional(this.bandwidthUpstreamVariable);
    }
    /**
     * Block packets originating from IP address that is not from this source
     *   - Default value: `false`
     * 
     */
    @Export(name="blockNonSourceIp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> blockNonSourceIp;

    /**
     * @return Block packets originating from IP address that is not from this source
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> blockNonSourceIp() {
        return Codegen.optional(this.blockNonSourceIp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="blockNonSourceIpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> blockNonSourceIpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> blockNonSourceIpVariable() {
        return Codegen.optional(this.blockNonSourceIpVariable);
    }
    /**
     * The description of the Feature
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of the Feature
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Duplex mode
     *   - Choices: `full`, `half`, `auto`
     * 
     */
    @Export(name="duplex", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> duplex;

    /**
     * @return Duplex mode
     *   - Choices: `full`, `half`, `auto`
     * 
     */
    public Output<Optional<String>> duplex() {
        return Codegen.optional(this.duplex);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="duplexVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> duplexVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> duplexVariable() {
        return Codegen.optional(this.duplexVariable);
    }
    /**
     * Enable DHCPv6, Attribute conditional on `ipv6ConfigurationType` being equal to `dynamic`
     * 
     */
    @Export(name="enableDhcpv6", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableDhcpv6;

    /**
     * @return Enable DHCPv6, Attribute conditional on `ipv6ConfigurationType` being equal to `dynamic`
     * 
     */
    public Output<Optional<Boolean>> enableDhcpv6() {
        return Codegen.optional(this.enableDhcpv6);
    }
    /**
     * Feature Profile ID
     * 
     */
    @Export(name="featureProfileId", refs={String.class}, tree="[0]")
    private Output<String> featureProfileId;

    /**
     * @return Feature Profile ID
     * 
     */
    public Output<String> featureProfileId() {
        return this.featureProfileId;
    }
    /**
     * GRE tunnel source IP
     * 
     */
    @Export(name="greTunnelSourceIp", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> greTunnelSourceIp;

    /**
     * @return GRE tunnel source IP
     * 
     */
    public Output<Optional<String>> greTunnelSourceIp() {
        return Codegen.optional(this.greTunnelSourceIp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="greTunnelSourceIpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> greTunnelSourceIpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> greTunnelSourceIpVariable() {
        return Codegen.optional(this.greTunnelSourceIpVariable);
    }
    /**
     * ICMP/ICMPv6 Redirect Disable
     *   - Default value: `true`
     * 
     */
    @Export(name="icmpRedirectDisable", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> icmpRedirectDisable;

    /**
     * @return ICMP/ICMPv6 Redirect Disable
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> icmpRedirectDisable() {
        return Codegen.optional(this.icmpRedirectDisable);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="icmpRedirectDisableVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> icmpRedirectDisableVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> icmpRedirectDisableVariable() {
        return Codegen.optional(this.icmpRedirectDisableVariable);
    }
    @Export(name="interfaceDescription", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceDescription;

    public Output<Optional<String>> interfaceDescription() {
        return Codegen.optional(this.interfaceDescription);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="interfaceDescriptionVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceDescriptionVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> interfaceDescriptionVariable() {
        return Codegen.optional(this.interfaceDescriptionVariable);
    }
    /**
     * Interface MTU GigabitEthernet0 &lt;1500..1518&gt;, Other GigabitEthernet &lt;1500..9216&gt; in bytes
     *   - Range: `1500`-`9216`
     *   - Default value: `1500`
     * 
     */
    @Export(name="interfaceMtu", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> interfaceMtu;

    /**
     * @return Interface MTU GigabitEthernet0 &lt;1500..1518&gt;, Other GigabitEthernet &lt;1500..9216&gt; in bytes
     *   - Range: `1500`-`9216`
     *   - Default value: `1500`
     * 
     */
    public Output<Optional<Integer>> interfaceMtu() {
        return Codegen.optional(this.interfaceMtu);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="interfaceMtuVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceMtuVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> interfaceMtuVariable() {
        return Codegen.optional(this.interfaceMtuVariable);
    }
    @Export(name="interfaceName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceName;

    public Output<Optional<String>> interfaceName() {
        return Codegen.optional(this.interfaceName);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="interfaceNameVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceNameVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> interfaceNameVariable() {
        return Codegen.optional(this.interfaceNameVariable);
    }
    /**
     * IP Directed-Broadcast
     *   - Default value: `false`
     * 
     */
    @Export(name="ipDirectedBroadcast", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ipDirectedBroadcast;

    /**
     * @return IP Directed-Broadcast
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> ipDirectedBroadcast() {
        return Codegen.optional(this.ipDirectedBroadcast);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipDirectedBroadcastVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipDirectedBroadcastVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipDirectedBroadcastVariable() {
        return Codegen.optional(this.ipDirectedBroadcastVariable);
    }
    /**
     * IP MTU for GigabitEthernet main &lt;576..Interface MTU&gt;, GigabitEthernet subinterface &lt;576..9216&gt;, Other Interfaces &lt;576..2000&gt; in bytes
     *   - Range: `576`-`9216`
     *   - Default value: `1500`
     * 
     */
    @Export(name="ipMtu", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipMtu;

    /**
     * @return IP MTU for GigabitEthernet main &lt;576..Interface MTU&gt;, GigabitEthernet subinterface &lt;576..9216&gt;, Other Interfaces &lt;576..2000&gt; in bytes
     *   - Range: `576`-`9216`
     *   - Default value: `1500`
     * 
     */
    public Output<Optional<Integer>> ipMtu() {
        return Codegen.optional(this.ipMtu);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipMtuVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipMtuVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipMtuVariable() {
        return Codegen.optional(this.ipMtuVariable);
    }
    /**
     * Iperf server for auto bandwidth detect
     * 
     */
    @Export(name="iperfServer", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> iperfServer;

    /**
     * @return Iperf server for auto bandwidth detect
     * 
     */
    public Output<Optional<String>> iperfServer() {
        return Codegen.optional(this.iperfServer);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="iperfServerVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> iperfServerVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> iperfServerVariable() {
        return Codegen.optional(this.iperfServerVariable);
    }
    /**
     * IP Address, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv4Address", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4Address;

    /**
     * @return IP Address, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<String>> ipv4Address() {
        return Codegen.optional(this.ipv4Address);
    }
    /**
     * Variable name, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv4AddressVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4AddressVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<String>> ipv4AddressVariable() {
        return Codegen.optional(this.ipv4AddressVariable);
    }
    /**
     * IPv4 Configuration Type
     *   - Choices: `dynamic`, `static`
     *   - Default value: `dynamic`
     * 
     */
    @Export(name="ipv4ConfigurationType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4ConfigurationType;

    /**
     * @return IPv4 Configuration Type
     *   - Choices: `dynamic`, `static`
     *   - Default value: `dynamic`
     * 
     */
    public Output<Optional<String>> ipv4ConfigurationType() {
        return Codegen.optional(this.ipv4ConfigurationType);
    }
    /**
     * DHCP Distance, Attribute conditional on `ipv4ConfigurationType` being equal to `dynamic`
     *   - Range: `1`-`65536`
     *   - Default value: `1`
     * 
     */
    @Export(name="ipv4DhcpDistance", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipv4DhcpDistance;

    /**
     * @return DHCP Distance, Attribute conditional on `ipv4ConfigurationType` being equal to `dynamic`
     *   - Range: `1`-`65536`
     *   - Default value: `1`
     * 
     */
    public Output<Optional<Integer>> ipv4DhcpDistance() {
        return Codegen.optional(this.ipv4DhcpDistance);
    }
    /**
     * Variable name, Attribute conditional on `ipv4ConfigurationType` being equal to `dynamic`
     * 
     */
    @Export(name="ipv4DhcpDistanceVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4DhcpDistanceVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv4ConfigurationType` being equal to `dynamic`
     * 
     */
    public Output<Optional<String>> ipv4DhcpDistanceVariable() {
        return Codegen.optional(this.ipv4DhcpDistanceVariable);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4DhcpHelperVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4DhcpHelperVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4DhcpHelperVariable() {
        return Codegen.optional(this.ipv4DhcpHelperVariable);
    }
    /**
     * List of DHCP IPv4 helper addresses (min 1, max 8)
     * 
     */
    @Export(name="ipv4DhcpHelpers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> ipv4DhcpHelpers;

    /**
     * @return List of DHCP IPv4 helper addresses (min 1, max 8)
     * 
     */
    public Output<Optional<List<String>>> ipv4DhcpHelpers() {
        return Codegen.optional(this.ipv4DhcpHelpers);
    }
    /**
     * Secondary IpV4 Addresses, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv4SecondaryAddresses", refs={List.class,TransportWanVpnInterfaceEthernetFeatureIpv4SecondaryAddress.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureIpv4SecondaryAddress>> ipv4SecondaryAddresses;

    /**
     * @return Secondary IpV4 Addresses, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureIpv4SecondaryAddress>>> ipv4SecondaryAddresses() {
        return Codegen.optional(this.ipv4SecondaryAddresses);
    }
    /**
     * Subnet Mask, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     *   - Choices: `255.255.255.255`, `255.255.255.254`, `255.255.255.252`, `255.255.255.248`, `255.255.255.240`, `255.255.255.224`, `255.255.255.192`, `255.255.255.128`, `255.255.255.0`, `255.255.254.0`, `255.255.252.0`, `255.255.248.0`, `255.255.240.0`, `255.255.224.0`, `255.255.192.0`, `255.255.128.0`, `255.255.0.0`, `255.254.0.0`, `255.252.0.0`, `255.240.0.0`, `255.224.0.0`, `255.192.0.0`, `255.128.0.0`, `255.0.0.0`, `254.0.0.0`, `252.0.0.0`, `248.0.0.0`, `240.0.0.0`, `224.0.0.0`, `192.0.0.0`, `128.0.0.0`, `0.0.0.0`
     * 
     */
    @Export(name="ipv4SubnetMask", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4SubnetMask;

    /**
     * @return Subnet Mask, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     *   - Choices: `255.255.255.255`, `255.255.255.254`, `255.255.255.252`, `255.255.255.248`, `255.255.255.240`, `255.255.255.224`, `255.255.255.192`, `255.255.255.128`, `255.255.255.0`, `255.255.254.0`, `255.255.252.0`, `255.255.248.0`, `255.255.240.0`, `255.255.224.0`, `255.255.192.0`, `255.255.128.0`, `255.255.0.0`, `255.254.0.0`, `255.252.0.0`, `255.240.0.0`, `255.224.0.0`, `255.192.0.0`, `255.128.0.0`, `255.0.0.0`, `254.0.0.0`, `252.0.0.0`, `248.0.0.0`, `240.0.0.0`, `224.0.0.0`, `192.0.0.0`, `128.0.0.0`, `0.0.0.0`
     * 
     */
    public Output<Optional<String>> ipv4SubnetMask() {
        return Codegen.optional(this.ipv4SubnetMask);
    }
    /**
     * Variable name, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv4SubnetMaskVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4SubnetMaskVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv4ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<String>> ipv4SubnetMaskVariable() {
        return Codegen.optional(this.ipv4SubnetMaskVariable);
    }
    /**
     * IPv6 Address Secondary, Attribute conditional on `ipv6ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv6Address", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv6Address;

    /**
     * @return IPv6 Address Secondary, Attribute conditional on `ipv6ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<String>> ipv6Address() {
        return Codegen.optional(this.ipv6Address);
    }
    /**
     * Variable name, Attribute conditional on `ipv6ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv6AddressVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv6AddressVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv6ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<String>> ipv6AddressVariable() {
        return Codegen.optional(this.ipv6AddressVariable);
    }
    /**
     * IPv6 Configuration Type
     *   - Choices: `dynamic`, `static`, `none`
     *   - Default value: `none`
     * 
     */
    @Export(name="ipv6ConfigurationType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv6ConfigurationType;

    /**
     * @return IPv6 Configuration Type
     *   - Choices: `dynamic`, `static`, `none`
     *   - Default value: `none`
     * 
     */
    public Output<Optional<String>> ipv6ConfigurationType() {
        return Codegen.optional(this.ipv6ConfigurationType);
    }
    /**
     * secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` being equal to `dynamic`
     * 
     */
    @Export(name="ipv6DhcpSecondaryAddresses", refs={List.class,TransportWanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress>> ipv6DhcpSecondaryAddresses;

    /**
     * @return secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` being equal to `dynamic`
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress>>> ipv6DhcpSecondaryAddresses() {
        return Codegen.optional(this.ipv6DhcpSecondaryAddresses);
    }
    /**
     * Static secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` being equal to `static`
     * 
     */
    @Export(name="ipv6SecondaryAddresses", refs={List.class,TransportWanVpnInterfaceEthernetFeatureIpv6SecondaryAddress.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureIpv6SecondaryAddress>> ipv6SecondaryAddresses;

    /**
     * @return Static secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` being equal to `static`
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureIpv6SecondaryAddress>>> ipv6SecondaryAddresses() {
        return Codegen.optional(this.ipv6SecondaryAddresses);
    }
    /**
     * Interval for interface load calculation
     *   - Range: `30`-`600`
     *   - Default value: `30`
     * 
     */
    @Export(name="loadInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> loadInterval;

    /**
     * @return Interval for interface load calculation
     *   - Range: `30`-`600`
     *   - Default value: `30`
     * 
     */
    public Output<Optional<Integer>> loadInterval() {
        return Codegen.optional(this.loadInterval);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="loadIntervalVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> loadIntervalVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> loadIntervalVariable() {
        return Codegen.optional(this.loadIntervalVariable);
    }
    /**
     * MAC Address
     * 
     */
    @Export(name="macAddress", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> macAddress;

    /**
     * @return MAC Address
     * 
     */
    public Output<Optional<String>> macAddress() {
        return Codegen.optional(this.macAddress);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="macAddressVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> macAddressVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> macAddressVariable() {
        return Codegen.optional(this.macAddressVariable);
    }
    /**
     * Media type
     *   - Choices: `auto-select`, `rj45`, `sfp`
     * 
     */
    @Export(name="mediaType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> mediaType;

    /**
     * @return Media type
     *   - Choices: `auto-select`, `rj45`, `sfp`
     * 
     */
    public Output<Optional<String>> mediaType() {
        return Codegen.optional(this.mediaType);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="mediaTypeVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> mediaTypeVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> mediaTypeVariable() {
        return Codegen.optional(this.mediaTypeVariable);
    }
    /**
     * The name of the Feature
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the Feature
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * NAT64 on this interface, Attribute conditional on `natIpv6` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="nat64", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nat64;

    /**
     * @return NAT64 on this interface, Attribute conditional on `natIpv6` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> nat64() {
        return Codegen.optional(this.nat64);
    }
    /**
     * NAT66 on this interface, Attribute conditional on `natIpv6` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="nat66", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nat66;

    /**
     * @return NAT66 on this interface, Attribute conditional on `natIpv6` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> nat66() {
        return Codegen.optional(this.nat66);
    }
    /**
     * enable Network Address Translation on this interface
     *   - Default value: `false`
     * 
     */
    @Export(name="natIpv4", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> natIpv4;

    /**
     * @return enable Network Address Translation on this interface
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> natIpv4() {
        return Codegen.optional(this.natIpv4);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="natIpv4Variable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natIpv4Variable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> natIpv4Variable() {
        return Codegen.optional(this.natIpv4Variable);
    }
    /**
     * enable Network Address Translation ipv6 on this interface
     *   - Default value: `false`
     * 
     */
    @Export(name="natIpv6", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> natIpv6;

    /**
     * @return enable Network Address Translation ipv6 on this interface
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> natIpv6() {
        return Codegen.optional(this.natIpv6);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="natIpv6Variable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natIpv6Variable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> natIpv6Variable() {
        return Codegen.optional(this.natIpv6Variable);
    }
    /**
     * NAT Inside Source Loopback Interface, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natLoopback", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natLoopback;

    /**
     * @return NAT Inside Source Loopback Interface, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natLoopback() {
        return Codegen.optional(this.natLoopback);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natLoopbackVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natLoopbackVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natLoopbackVariable() {
        return Codegen.optional(this.natLoopbackVariable);
    }
    /**
     * NAT Overload, Attribute conditional on `natIpv4` being equal to `true`
     *   - Default value: `true`
     * 
     */
    @Export(name="natOverload", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> natOverload;

    /**
     * @return NAT Overload, Attribute conditional on `natIpv4` being equal to `true`
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> natOverload() {
        return Codegen.optional(this.natOverload);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natOverloadVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natOverloadVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natOverloadVariable() {
        return Codegen.optional(this.natOverloadVariable);
    }
    /**
     * NAT Pool Prefix Length, Attribute conditional on `natIpv4` being equal to `true`
     *   - Range: `1`-`32`
     * 
     */
    @Export(name="natPrefixLength", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> natPrefixLength;

    /**
     * @return NAT Pool Prefix Length, Attribute conditional on `natIpv4` being equal to `true`
     *   - Range: `1`-`32`
     * 
     */
    public Output<Optional<Integer>> natPrefixLength() {
        return Codegen.optional(this.natPrefixLength);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natPrefixLengthVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natPrefixLengthVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natPrefixLengthVariable() {
        return Codegen.optional(this.natPrefixLengthVariable);
    }
    /**
     * NAT Pool Range End, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natRangeEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natRangeEnd;

    /**
     * @return NAT Pool Range End, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natRangeEnd() {
        return Codegen.optional(this.natRangeEnd);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natRangeEndVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natRangeEndVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natRangeEndVariable() {
        return Codegen.optional(this.natRangeEndVariable);
    }
    /**
     * NAT Pool Range Start, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natRangeStart", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natRangeStart;

    /**
     * @return NAT Pool Range Start, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natRangeStart() {
        return Codegen.optional(this.natRangeStart);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natRangeStartVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natRangeStartVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natRangeStartVariable() {
        return Codegen.optional(this.natRangeStartVariable);
    }
    /**
     * Set NAT TCP session timeout, in minutes, Attribute conditional on `natIpv4` being equal to `true`
     *   - Range: `1`-`8947`
     *   - Default value: `60`
     * 
     */
    @Export(name="natTcpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> natTcpTimeout;

    /**
     * @return Set NAT TCP session timeout, in minutes, Attribute conditional on `natIpv4` being equal to `true`
     *   - Range: `1`-`8947`
     *   - Default value: `60`
     * 
     */
    public Output<Optional<Integer>> natTcpTimeout() {
        return Codegen.optional(this.natTcpTimeout);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natTcpTimeoutVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natTcpTimeoutVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natTcpTimeoutVariable() {
        return Codegen.optional(this.natTcpTimeoutVariable);
    }
    /**
     * NAT Type, Attribute conditional on `natIpv4` being equal to `true`
     *   - Choices: `interface`, `pool`, `loopback`
     *   - Default value: `interface`
     * 
     */
    @Export(name="natType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natType;

    /**
     * @return NAT Type, Attribute conditional on `natIpv4` being equal to `true`
     *   - Choices: `interface`, `pool`, `loopback`
     *   - Default value: `interface`
     * 
     */
    public Output<Optional<String>> natType() {
        return Codegen.optional(this.natType);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natTypeVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natTypeVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natTypeVariable() {
        return Codegen.optional(this.natTypeVariable);
    }
    /**
     * Set NAT UDP session timeout, in minutes, Attribute conditional on `natIpv4` being equal to `true`
     *   - Range: `1`-`8947`
     *   - Default value: `1`
     * 
     */
    @Export(name="natUdpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> natUdpTimeout;

    /**
     * @return Set NAT UDP session timeout, in minutes, Attribute conditional on `natIpv4` being equal to `true`
     *   - Range: `1`-`8947`
     *   - Default value: `1`
     * 
     */
    public Output<Optional<Integer>> natUdpTimeout() {
        return Codegen.optional(this.natUdpTimeout);
    }
    /**
     * Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="natUdpTimeoutVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> natUdpTimeoutVariable;

    /**
     * @return Variable name, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<String>> natUdpTimeoutVariable() {
        return Codegen.optional(this.natUdpTimeoutVariable);
    }
    /**
     * static NAT, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    @Export(name="newStaticNats", refs={List.class,TransportWanVpnInterfaceEthernetFeatureNewStaticNat.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureNewStaticNat>> newStaticNats;

    /**
     * @return static NAT, Attribute conditional on `natIpv4` being equal to `true`
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureNewStaticNat>>> newStaticNats() {
        return Codegen.optional(this.newStaticNats);
    }
    /**
     * Per-tunnel Qos, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="perTunnelQos", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> perTunnelQos;

    /**
     * @return Per-tunnel Qos, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> perTunnelQos() {
        return Codegen.optional(this.perTunnelQos);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="perTunnelQosVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> perTunnelQosVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> perTunnelQosVariable() {
        return Codegen.optional(this.perTunnelQosVariable);
    }
    /**
     * Adaptive QoS
     *   - Default value: `false`
     * 
     */
    @Export(name="qosAdaptive", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> qosAdaptive;

    /**
     * @return Adaptive QoS
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> qosAdaptive() {
        return Codegen.optional(this.qosAdaptive);
    }
    /**
     * Shaping Rate Downstream
     *   - Default value: `false`
     * 
     */
    @Export(name="qosAdaptiveBandwidthDownstream", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> qosAdaptiveBandwidthDownstream;

    /**
     * @return Shaping Rate Downstream
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> qosAdaptiveBandwidthDownstream() {
        return Codegen.optional(this.qosAdaptiveBandwidthDownstream);
    }
    /**
     * Shaping Rate Upstream
     *   - Default value: `false`
     * 
     */
    @Export(name="qosAdaptiveBandwidthUpstream", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> qosAdaptiveBandwidthUpstream;

    /**
     * @return Shaping Rate Upstream
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> qosAdaptiveBandwidthUpstream() {
        return Codegen.optional(this.qosAdaptiveBandwidthUpstream);
    }
    /**
     * Adaptive QoS default downstream bandwidth (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosAdaptiveDefaultDownstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptiveDefaultDownstream;

    /**
     * @return Adaptive QoS default downstream bandwidth (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosAdaptiveDefaultDownstream() {
        return Codegen.optional(this.qosAdaptiveDefaultDownstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptiveDefaultDownstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptiveDefaultDownstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptiveDefaultDownstreamVariable() {
        return Codegen.optional(this.qosAdaptiveDefaultDownstreamVariable);
    }
    /**
     * Adaptive QoS default upstream bandwidth (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosAdaptiveDefaultUpstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptiveDefaultUpstream;

    /**
     * @return Adaptive QoS default upstream bandwidth (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosAdaptiveDefaultUpstream() {
        return Codegen.optional(this.qosAdaptiveDefaultUpstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptiveDefaultUpstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptiveDefaultUpstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptiveDefaultUpstreamVariable() {
        return Codegen.optional(this.qosAdaptiveDefaultUpstreamVariable);
    }
    /**
     * Downstream max bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosAdaptiveMaxDownstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptiveMaxDownstream;

    /**
     * @return Downstream max bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosAdaptiveMaxDownstream() {
        return Codegen.optional(this.qosAdaptiveMaxDownstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptiveMaxDownstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptiveMaxDownstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptiveMaxDownstreamVariable() {
        return Codegen.optional(this.qosAdaptiveMaxDownstreamVariable);
    }
    /**
     * Upstream max bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosAdaptiveMaxUpstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptiveMaxUpstream;

    /**
     * @return Upstream max bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosAdaptiveMaxUpstream() {
        return Codegen.optional(this.qosAdaptiveMaxUpstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptiveMaxUpstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptiveMaxUpstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptiveMaxUpstreamVariable() {
        return Codegen.optional(this.qosAdaptiveMaxUpstreamVariable);
    }
    /**
     * Downstream min bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosAdaptiveMinDownstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptiveMinDownstream;

    /**
     * @return Downstream min bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosAdaptiveMinDownstream() {
        return Codegen.optional(this.qosAdaptiveMinDownstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptiveMinDownstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptiveMinDownstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptiveMinDownstreamVariable() {
        return Codegen.optional(this.qosAdaptiveMinDownstreamVariable);
    }
    /**
     * Upstream min bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosAdaptiveMinUpstream", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptiveMinUpstream;

    /**
     * @return Upstream min bandwidth limit (kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosAdaptiveMinUpstream() {
        return Codegen.optional(this.qosAdaptiveMinUpstream);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptiveMinUpstreamVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptiveMinUpstreamVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptiveMinUpstreamVariable() {
        return Codegen.optional(this.qosAdaptiveMinUpstreamVariable);
    }
    /**
     * Adapt Period(Minutes)
     *   - Range: `1`-`720`
     *   - Default value: `15`
     * 
     */
    @Export(name="qosAdaptivePeriod", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosAdaptivePeriod;

    /**
     * @return Adapt Period(Minutes)
     *   - Range: `1`-`720`
     *   - Default value: `15`
     * 
     */
    public Output<Optional<Integer>> qosAdaptivePeriod() {
        return Codegen.optional(this.qosAdaptivePeriod);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosAdaptivePeriodVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosAdaptivePeriodVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosAdaptivePeriodVariable() {
        return Codegen.optional(this.qosAdaptivePeriodVariable);
    }
    /**
     * Shaping Rate (Kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="qosShapingRate", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> qosShapingRate;

    /**
     * @return Shaping Rate (Kbps)
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> qosShapingRate() {
        return Codegen.optional(this.qosShapingRate);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="qosShapingRateVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> qosShapingRateVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> qosShapingRateVariable() {
        return Codegen.optional(this.qosShapingRateVariable);
    }
    /**
     * Service Provider Name
     * 
     */
    @Export(name="serviceProvider", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> serviceProvider;

    /**
     * @return Service Provider Name
     * 
     */
    public Output<Optional<String>> serviceProvider() {
        return Codegen.optional(this.serviceProvider);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="serviceProviderVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> serviceProviderVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> serviceProviderVariable() {
        return Codegen.optional(this.serviceProviderVariable);
    }
    /**
     * - Default value: `true`
     * 
     */
    @Export(name="shutdown", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> shutdown;

    /**
     * @return - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> shutdown() {
        return Codegen.optional(this.shutdown);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="shutdownVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> shutdownVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> shutdownVariable() {
        return Codegen.optional(this.shutdownVariable);
    }
    /**
     * Set interface speed
     *   - Choices: `10`, `100`, `1000`, `2500`, `10000`
     * 
     */
    @Export(name="speed", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> speed;

    /**
     * @return Set interface speed
     *   - Choices: `10`, `100`, `1000`, `2500`, `10000`
     * 
     */
    public Output<Optional<String>> speed() {
        return Codegen.optional(this.speed);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="speedVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> speedVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> speedVariable() {
        return Codegen.optional(this.speedVariable);
    }
    /**
     * static NAT66, Attribute conditional on `natIpv6` being equal to `true`
     * 
     */
    @Export(name="staticNat66s", refs={List.class,TransportWanVpnInterfaceEthernetFeatureStaticNat66.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureStaticNat66>> staticNat66s;

    /**
     * @return static NAT66, Attribute conditional on `natIpv6` being equal to `true`
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureStaticNat66>>> staticNat66s() {
        return Codegen.optional(this.staticNat66s);
    }
    /**
     * TCP MSS on SYN packets, in bytes
     *   - Range: `500`-`1460`
     * 
     */
    @Export(name="tcpMss", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tcpMss;

    /**
     * @return TCP MSS on SYN packets, in bytes
     *   - Range: `500`-`1460`
     * 
     */
    public Output<Optional<Integer>> tcpMss() {
        return Codegen.optional(this.tcpMss);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tcpMssVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tcpMssVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tcpMssVariable() {
        return Codegen.optional(this.tcpMssVariable);
    }
    /**
     * Extends a local TLOC to a remote node only for vpn 0
     * 
     */
    @Export(name="tlocExtension", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tlocExtension;

    /**
     * @return Extends a local TLOC to a remote node only for vpn 0
     * 
     */
    public Output<Optional<String>> tlocExtension() {
        return Codegen.optional(this.tlocExtension);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tlocExtensionVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tlocExtensionVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tlocExtensionVariable() {
        return Codegen.optional(this.tlocExtensionVariable);
    }
    /**
     * Enable tracker for this interface
     * 
     */
    @Export(name="tracker", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tracker;

    /**
     * @return Enable tracker for this interface
     * 
     */
    public Output<Optional<String>> tracker() {
        return Codegen.optional(this.tracker);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="trackerVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> trackerVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> trackerVariable() {
        return Codegen.optional(this.trackerVariable);
    }
    /**
     * Transport WAN VPN Feature ID
     * 
     */
    @Export(name="transportWanVpnFeatureId", refs={String.class}, tree="[0]")
    private Output<String> transportWanVpnFeatureId;

    /**
     * @return Transport WAN VPN Feature ID
     * 
     */
    public Output<String> transportWanVpnFeatureId() {
        return this.transportWanVpnFeatureId;
    }
    /**
     * Tunnels Bandwidth Percent, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `1`-`100`
     *   - Default value: `50`
     * 
     */
    @Export(name="tunnelBandwidthPercent", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelBandwidthPercent;

    /**
     * @return Tunnels Bandwidth Percent, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `1`-`100`
     *   - Default value: `50`
     * 
     */
    public Output<Optional<Integer>> tunnelBandwidthPercent() {
        return Codegen.optional(this.tunnelBandwidthPercent);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelBandwidthPercentVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelBandwidthPercentVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelBandwidthPercentVariable() {
        return Codegen.optional(this.tunnelBandwidthPercentVariable);
    }
    /**
     * Tunnel Interface on/off
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterface", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterface;

    /**
     * @return Tunnel Interface on/off
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterface() {
        return Codegen.optional(this.tunnelInterface);
    }
    /**
     * Allow all traffic. Overrides all other allow-service options if allow-service all is set
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowAll", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowAll;

    /**
     * @return Allow all traffic. Overrides all other allow-service options if allow-service all is set
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowAll() {
        return Codegen.optional(this.tunnelInterfaceAllowAll);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowAllVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowAllVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowAllVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowAllVariable);
    }
    /**
     * Allow/Deny BFD
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowBfd", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowBfd;

    /**
     * @return Allow/Deny BFD
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowBfd() {
        return Codegen.optional(this.tunnelInterfaceAllowBfd);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowBfdVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowBfdVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowBfdVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowBfdVariable);
    }
    /**
     * Allow/deny BGP
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowBgp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowBgp;

    /**
     * @return Allow/deny BGP
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowBgp() {
        return Codegen.optional(this.tunnelInterfaceAllowBgp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowBgpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowBgpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowBgpVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowBgpVariable);
    }
    /**
     * Allow/Deny DHCP
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfaceAllowDhcp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowDhcp;

    /**
     * @return Allow/Deny DHCP
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowDhcp() {
        return Codegen.optional(this.tunnelInterfaceAllowDhcp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowDhcpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowDhcpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowDhcpVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowDhcpVariable);
    }
    /**
     * Allow/Deny DNS
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfaceAllowDns", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowDns;

    /**
     * @return Allow/Deny DNS
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowDns() {
        return Codegen.optional(this.tunnelInterfaceAllowDns);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowDnsVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowDnsVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowDnsVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowDnsVariable);
    }
    /**
     * Allow/Deny HTTPS
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfaceAllowHttps", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowHttps;

    /**
     * @return Allow/Deny HTTPS
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowHttps() {
        return Codegen.optional(this.tunnelInterfaceAllowHttps);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowHttpsVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowHttpsVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowHttpsVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowHttpsVariable);
    }
    /**
     * Allow/Deny ICMP
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfaceAllowIcmp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowIcmp;

    /**
     * @return Allow/Deny ICMP
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowIcmp() {
        return Codegen.optional(this.tunnelInterfaceAllowIcmp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowIcmpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowIcmpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowIcmpVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowIcmpVariable);
    }
    /**
     * Allow/Deny NETCONF
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowNetconf", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowNetconf;

    /**
     * @return Allow/Deny NETCONF
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowNetconf() {
        return Codegen.optional(this.tunnelInterfaceAllowNetconf);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowNetconfVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowNetconfVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowNetconfVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowNetconfVariable);
    }
    /**
     * Allow/Deny NTP
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfaceAllowNtp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowNtp;

    /**
     * @return Allow/Deny NTP
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowNtp() {
        return Codegen.optional(this.tunnelInterfaceAllowNtp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowNtpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowNtpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowNtpVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowNtpVariable);
    }
    /**
     * Allow/Deny OSPF
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowOspf", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowOspf;

    /**
     * @return Allow/Deny OSPF
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowOspf() {
        return Codegen.optional(this.tunnelInterfaceAllowOspf);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowOspfVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowOspfVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowOspfVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowOspfVariable);
    }
    /**
     * Allow/Deny SNMP
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowSnmp", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowSnmp;

    /**
     * @return Allow/Deny SNMP
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowSnmp() {
        return Codegen.optional(this.tunnelInterfaceAllowSnmp);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowSnmpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowSnmpVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowSnmpVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowSnmpVariable);
    }
    /**
     * Allow/Deny SSH
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfaceAllowSsh", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowSsh;

    /**
     * @return Allow/Deny SSH
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowSsh() {
        return Codegen.optional(this.tunnelInterfaceAllowSsh);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowSshVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowSshVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowSshVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowSshVariable);
    }
    /**
     * Allow/Deny STUN
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceAllowStun", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceAllowStun;

    /**
     * @return Allow/Deny STUN
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceAllowStun() {
        return Codegen.optional(this.tunnelInterfaceAllowStun);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="tunnelInterfaceAllowStunVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceAllowStunVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> tunnelInterfaceAllowStunVariable() {
        return Codegen.optional(this.tunnelInterfaceAllowStunVariable);
    }
    /**
     * Bind loopback tunnel interface to a physical interface, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceBindLoopbackTunnel", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceBindLoopbackTunnel;

    /**
     * @return Bind loopback tunnel interface to a physical interface, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceBindLoopbackTunnel() {
        return Codegen.optional(this.tunnelInterfaceBindLoopbackTunnel);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceBindLoopbackTunnelVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceBindLoopbackTunnelVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceBindLoopbackTunnelVariable() {
        return Codegen.optional(this.tunnelInterfaceBindLoopbackTunnelVariable);
    }
    /**
     * Set TLOC as border TLOC, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceBorder", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceBorder;

    /**
     * @return Set TLOC as border TLOC, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceBorder() {
        return Codegen.optional(this.tunnelInterfaceBorder);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceBorderVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceBorderVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceBorderVariable() {
        return Codegen.optional(this.tunnelInterfaceBorderVariable);
    }
    /**
     * Set carrier for TLOC, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Choices: `default`, `carrier1`, `carrier2`, `carrier3`, `carrier4`, `carrier5`, `carrier6`, `carrier7`, `carrier8`
     *   - Default value: `default`
     * 
     */
    @Export(name="tunnelInterfaceCarrier", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceCarrier;

    /**
     * @return Set carrier for TLOC, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Choices: `default`, `carrier1`, `carrier2`, `carrier3`, `carrier4`, `carrier5`, `carrier6`, `carrier7`, `carrier8`
     *   - Default value: `default`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceCarrier() {
        return Codegen.optional(this.tunnelInterfaceCarrier);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceCarrierVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceCarrierVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceCarrierVariable() {
        return Codegen.optional(this.tunnelInterfaceCarrierVariable);
    }
    /**
     * Enable clear dont fragment (Currently Only SDWAN Tunnel Interface), Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceClearDontFragment", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceClearDontFragment;

    /**
     * @return Enable clear dont fragment (Currently Only SDWAN Tunnel Interface), Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceClearDontFragment() {
        return Codegen.optional(this.tunnelInterfaceClearDontFragment);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceClearDontFragmentVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceClearDontFragmentVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceClearDontFragmentVariable() {
        return Codegen.optional(this.tunnelInterfaceClearDontFragmentVariable);
    }
    /**
     * Set color for TLOC, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Choices: `default`, `mpls`, `metro-ethernet`, `biz-internet`, `public-internet`, `lte`, `3g`, `red`, `green`, `blue`, `gold`, `silver`, `bronze`, `custom1`, `custom2`, `custom3`, `private1`, `private2`, `private3`, `private4`, `private5`, `private6`
     *   - Default value: `mpls`
     * 
     */
    @Export(name="tunnelInterfaceColor", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceColor;

    /**
     * @return Set color for TLOC, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Choices: `default`, `mpls`, `metro-ethernet`, `biz-internet`, `public-internet`, `lte`, `3g`, `red`, `green`, `blue`, `gold`, `silver`, `bronze`, `custom1`, `custom2`, `custom3`, `private1`, `private2`, `private3`, `private4`, `private5`, `private6`
     *   - Default value: `mpls`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceColor() {
        return Codegen.optional(this.tunnelInterfaceColor);
    }
    /**
     * Restrict this TLOC behavior, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceColorRestrict", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceColorRestrict;

    /**
     * @return Restrict this TLOC behavior, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceColorRestrict() {
        return Codegen.optional(this.tunnelInterfaceColorRestrict);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceColorRestrictVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceColorRestrictVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceColorRestrictVariable() {
        return Codegen.optional(this.tunnelInterfaceColorRestrictVariable);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceColorVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceColorVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceColorVariable() {
        return Codegen.optional(this.tunnelInterfaceColorVariable);
    }
    /**
     * CTS SGT Propagation configuration, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceCtsSgtPropagation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceCtsSgtPropagation;

    /**
     * @return CTS SGT Propagation configuration, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceCtsSgtPropagation() {
        return Codegen.optional(this.tunnelInterfaceCtsSgtPropagation);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceCtsSgtPropagationVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceCtsSgtPropagationVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceCtsSgtPropagationVariable() {
        return Codegen.optional(this.tunnelInterfaceCtsSgtPropagationVariable);
    }
    /**
     * Encapsulation for TLOC
     * 
     */
    @Export(name="tunnelInterfaceEncapsulations", refs={List.class,TransportWanVpnInterfaceEthernetFeatureTunnelInterfaceEncapsulation.class}, tree="[0,1]")
    private Output</* @Nullable */ List<TransportWanVpnInterfaceEthernetFeatureTunnelInterfaceEncapsulation>> tunnelInterfaceEncapsulations;

    /**
     * @return Encapsulation for TLOC
     * 
     */
    public Output<Optional<List<TransportWanVpnInterfaceEthernetFeatureTunnelInterfaceEncapsulation>>> tunnelInterfaceEncapsulations() {
        return Codegen.optional(this.tunnelInterfaceEncapsulations);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceExcludeControllerGroupListVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceExcludeControllerGroupListVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceExcludeControllerGroupListVariable() {
        return Codegen.optional(this.tunnelInterfaceExcludeControllerGroupListVariable);
    }
    /**
     * Exclude the following controller groups defined in this list., Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceExcludeControllerGroupLists", refs={List.class,Integer.class}, tree="[0,1]")
    private Output</* @Nullable */ List<Integer>> tunnelInterfaceExcludeControllerGroupLists;

    /**
     * @return Exclude the following controller groups defined in this list., Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<List<Integer>>> tunnelInterfaceExcludeControllerGroupLists() {
        return Codegen.optional(this.tunnelInterfaceExcludeControllerGroupLists);
    }
    /**
     * GRE tunnel destination IP, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceGreTunnelDestinationIp", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceGreTunnelDestinationIp;

    /**
     * @return GRE tunnel destination IP, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceGreTunnelDestinationIp() {
        return Codegen.optional(this.tunnelInterfaceGreTunnelDestinationIp);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceGreTunnelDestinationIpVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceGreTunnelDestinationIpVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceGreTunnelDestinationIpVariable() {
        return Codegen.optional(this.tunnelInterfaceGreTunnelDestinationIpVariable);
    }
    /**
     * List of groups, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `1`-`4294967295`
     * 
     */
    @Export(name="tunnelInterfaceGroups", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceGroups;

    /**
     * @return List of groups, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `1`-`4294967295`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceGroups() {
        return Codegen.optional(this.tunnelInterfaceGroups);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceGroupsVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceGroupsVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceGroupsVariable() {
        return Codegen.optional(this.tunnelInterfaceGroupsVariable);
    }
    /**
     * Set time period of control hello packets &lt;100..600000&gt; milli seconds, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `100`-`600000`
     *   - Default value: `1000`
     * 
     */
    @Export(name="tunnelInterfaceHelloInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceHelloInterval;

    /**
     * @return Set time period of control hello packets &lt;100..600000&gt; milli seconds, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `100`-`600000`
     *   - Default value: `1000`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceHelloInterval() {
        return Codegen.optional(this.tunnelInterfaceHelloInterval);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceHelloIntervalVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceHelloIntervalVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceHelloIntervalVariable() {
        return Codegen.optional(this.tunnelInterfaceHelloIntervalVariable);
    }
    /**
     * Set tolerance of control hello packets &lt;12..6000&gt; seconds, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `12`-`6000`
     *   - Default value: `12`
     * 
     */
    @Export(name="tunnelInterfaceHelloTolerance", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceHelloTolerance;

    /**
     * @return Set tolerance of control hello packets &lt;12..6000&gt; seconds, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `12`-`6000`
     *   - Default value: `12`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceHelloTolerance() {
        return Codegen.optional(this.tunnelInterfaceHelloTolerance);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceHelloToleranceVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceHelloToleranceVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceHelloToleranceVariable() {
        return Codegen.optional(this.tunnelInterfaceHelloToleranceVariable);
    }
    /**
     * Set TLOC as last resort, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceLastResortCircuit", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceLastResortCircuit;

    /**
     * @return Set TLOC as last resort, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceLastResortCircuit() {
        return Codegen.optional(this.tunnelInterfaceLastResortCircuit);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceLastResortCircuitVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceLastResortCircuitVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceLastResortCircuitVariable() {
        return Codegen.optional(this.tunnelInterfaceLastResortCircuitVariable);
    }
    /**
     * Set the interface as a low-bandwidth circuit, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceLowBandwidthLink", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceLowBandwidthLink;

    /**
     * @return Set the interface as a low-bandwidth circuit, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceLowBandwidthLink() {
        return Codegen.optional(this.tunnelInterfaceLowBandwidthLink);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceLowBandwidthLinkVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceLowBandwidthLinkVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceLowBandwidthLinkVariable() {
        return Codegen.optional(this.tunnelInterfaceLowBandwidthLinkVariable);
    }
    /**
     * Maximum Control Connections, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `0`-`100`
     * 
     */
    @Export(name="tunnelInterfaceMaxControlConnections", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceMaxControlConnections;

    /**
     * @return Maximum Control Connections, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `0`-`100`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceMaxControlConnections() {
        return Codegen.optional(this.tunnelInterfaceMaxControlConnections);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceMaxControlConnectionsVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceMaxControlConnectionsVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceMaxControlConnectionsVariable() {
        return Codegen.optional(this.tunnelInterfaceMaxControlConnectionsVariable);
    }
    /**
     * Set time period of nat refresh packets &lt;1...60&gt; seconds, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `1`-`60`
     *   - Default value: `5`
     * 
     */
    @Export(name="tunnelInterfaceNatRefreshInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceNatRefreshInterval;

    /**
     * @return Set time period of nat refresh packets &lt;1...60&gt; seconds, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `1`-`60`
     *   - Default value: `5`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceNatRefreshInterval() {
        return Codegen.optional(this.tunnelInterfaceNatRefreshInterval);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceNatRefreshIntervalVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceNatRefreshIntervalVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceNatRefreshIntervalVariable() {
        return Codegen.optional(this.tunnelInterfaceNatRefreshIntervalVariable);
    }
    /**
     * Accept and respond to network-prefix-directed broadcasts, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceNetworkBroadcast", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceNetworkBroadcast;

    /**
     * @return Accept and respond to network-prefix-directed broadcasts, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceNetworkBroadcast() {
        return Codegen.optional(this.tunnelInterfaceNetworkBroadcast);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceNetworkBroadcastVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceNetworkBroadcastVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceNetworkBroadcastVariable() {
        return Codegen.optional(this.tunnelInterfaceNetworkBroadcastVariable);
    }
    /**
     * Disallow port hopping on the tunnel interface, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `true`
     * 
     */
    @Export(name="tunnelInterfacePortHop", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfacePortHop;

    /**
     * @return Disallow port hopping on the tunnel interface, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfacePortHop() {
        return Codegen.optional(this.tunnelInterfacePortHop);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfacePortHopVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfacePortHopVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfacePortHopVariable() {
        return Codegen.optional(this.tunnelInterfacePortHopVariable);
    }
    /**
     * Tunnel TCP MSS on SYN packets, in bytes, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `500`-`1460`
     * 
     */
    @Export(name="tunnelInterfaceTunnelTcpMss", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceTunnelTcpMss;

    /**
     * @return Tunnel TCP MSS on SYN packets, in bytes, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `500`-`1460`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceTunnelTcpMss() {
        return Codegen.optional(this.tunnelInterfaceTunnelTcpMss);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceTunnelTcpMssVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceTunnelTcpMssVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceTunnelTcpMssVariable() {
        return Codegen.optional(this.tunnelInterfaceTunnelTcpMssVariable);
    }
    /**
     * Put this wan interface in STUN mode only, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="tunnelInterfaceVbondAsStunServer", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> tunnelInterfaceVbondAsStunServer;

    /**
     * @return Put this wan interface in STUN mode only, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> tunnelInterfaceVbondAsStunServer() {
        return Codegen.optional(this.tunnelInterfaceVbondAsStunServer);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceVbondAsStunServerVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceVbondAsStunServerVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceVbondAsStunServerVariable() {
        return Codegen.optional(this.tunnelInterfaceVbondAsStunServerVariable);
    }
    /**
     * Set interface preference for control connection to vManage &lt;0..8&gt;, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `0`-`8`
     *   - Default value: `5`
     * 
     */
    @Export(name="tunnelInterfaceVmanageConnectionPreference", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tunnelInterfaceVmanageConnectionPreference;

    /**
     * @return Set interface preference for control connection to vManage &lt;0..8&gt;, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Range: `0`-`8`
     *   - Default value: `5`
     * 
     */
    public Output<Optional<Integer>> tunnelInterfaceVmanageConnectionPreference() {
        return Codegen.optional(this.tunnelInterfaceVmanageConnectionPreference);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelInterfaceVmanageConnectionPreferenceVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelInterfaceVmanageConnectionPreferenceVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelInterfaceVmanageConnectionPreferenceVariable() {
        return Codegen.optional(this.tunnelInterfaceVmanageConnectionPreferenceVariable);
    }
    /**
     * Set tunnel QoS mode, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Choices: `hub`, `spoke`
     * 
     */
    @Export(name="tunnelQosMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelQosMode;

    /**
     * @return Set tunnel QoS mode, Attribute conditional on `tunnelInterface` being equal to `true`
     *   - Choices: `hub`, `spoke`
     * 
     */
    public Output<Optional<String>> tunnelQosMode() {
        return Codegen.optional(this.tunnelQosMode);
    }
    /**
     * Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    @Export(name="tunnelQosModeVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tunnelQosModeVariable;

    /**
     * @return Variable name, Attribute conditional on `tunnelInterface` being equal to `true`
     * 
     */
    public Output<Optional<String>> tunnelQosModeVariable() {
        return Codegen.optional(this.tunnelQosModeVariable);
    }
    /**
     * The version of the Feature
     * 
     */
    @Export(name="version", refs={Integer.class}, tree="[0]")
    private Output<Integer> version;

    /**
     * @return The version of the Feature
     * 
     */
    public Output<Integer> version() {
        return this.version;
    }
    /**
     * Extend remote TLOC over a GRE tunnel to a local WAN interface
     * 
     */
    @Export(name="xconnect", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> xconnect;

    /**
     * @return Extend remote TLOC over a GRE tunnel to a local WAN interface
     * 
     */
    public Output<Optional<String>> xconnect() {
        return Codegen.optional(this.xconnect);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="xconnectVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> xconnectVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> xconnectVariable() {
        return Codegen.optional(this.xconnectVariable);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public TransportWanVpnInterfaceEthernetFeature(java.lang.String name) {
        this(name, TransportWanVpnInterfaceEthernetFeatureArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public TransportWanVpnInterfaceEthernetFeature(java.lang.String name, TransportWanVpnInterfaceEthernetFeatureArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public TransportWanVpnInterfaceEthernetFeature(java.lang.String name, TransportWanVpnInterfaceEthernetFeatureArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("sdwan:index/transportWanVpnInterfaceEthernetFeature:TransportWanVpnInterfaceEthernetFeature", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private TransportWanVpnInterfaceEthernetFeature(java.lang.String name, Output<java.lang.String> id, @Nullable TransportWanVpnInterfaceEthernetFeatureState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("sdwan:index/transportWanVpnInterfaceEthernetFeature:TransportWanVpnInterfaceEthernetFeature", name, state, makeResourceOptions(options, id), false);
    }

    private static TransportWanVpnInterfaceEthernetFeatureArgs makeArgs(TransportWanVpnInterfaceEthernetFeatureArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? TransportWanVpnInterfaceEthernetFeatureArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static TransportWanVpnInterfaceEthernetFeature get(java.lang.String name, Output<java.lang.String> id, @Nullable TransportWanVpnInterfaceEthernetFeatureState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new TransportWanVpnInterfaceEthernetFeature(name, id, state, options);
    }
}
