// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.sdwan;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.sdwan.ServiceLanVpnInterfaceEthernetFeatureArgs;
import com.pulumi.sdwan.Utilities;
import com.pulumi.sdwan.inputs.ServiceLanVpnInterfaceEthernetFeatureState;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureArp;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureIpv4SecondaryAddress;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureIpv4Vrrp;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpHelper;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureIpv6SecondaryAddress;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureIpv6Vrrp;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeaturePortChannelLacpMemberLink;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeaturePortChannelStaticMemberLink;
import com.pulumi.sdwan.outputs.ServiceLanVpnInterfaceEthernetFeatureStaticNat;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * This resource can manage a Service LAN VPN Interface Ethernet Feature.
 *   - Minimum SD-WAN Manager version: `20.15.0`
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.sdwan.ServiceLanVpnInterfaceEthernetFeature;
 * import com.pulumi.sdwan.ServiceLanVpnInterfaceEthernetFeatureArgs;
 * import com.pulumi.sdwan.inputs.ServiceLanVpnInterfaceEthernetFeatureIpv4SecondaryAddressArgs;
 * import com.pulumi.sdwan.inputs.ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpHelperArgs;
 * import com.pulumi.sdwan.inputs.ServiceLanVpnInterfaceEthernetFeatureIpv6VrrpArgs;
 * import com.pulumi.sdwan.inputs.ServiceLanVpnInterfaceEthernetFeatureIpv4VrrpArgs;
 * import com.pulumi.sdwan.inputs.ServiceLanVpnInterfaceEthernetFeatureArpArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new ServiceLanVpnInterfaceEthernetFeature("example", ServiceLanVpnInterfaceEthernetFeatureArgs.builder()
 *             .name("Example")
 *             .description("My Example")
 *             .featureProfileId("f6dd22c8-0b4f-496c-9a0b-6813d1f8b8ac")
 *             .serviceLanVpnFeatureId("140331f6-5418-4755-a059-13c77eb96037")
 *             .shutdown(false)
 *             .interfaceName("GigabitEthernet3")
 *             .interfaceDescription("LAN")
 *             .ipv4ConfigurationType("static")
 *             .ipv4Address("1.2.3.4")
 *             .ipv4SubnetMask("0.0.0.0")
 *             .ipv4SecondaryAddresses(ServiceLanVpnInterfaceEthernetFeatureIpv4SecondaryAddressArgs.builder()
 *                 .address("1.2.3.5")
 *                 .subnetMask("0.0.0.0")
 *                 .build())
 *             .ipv4DhcpHelpers("1.2.3.4")
 *             .ipv6ConfigurationType("static")
 *             .ipv6DhcpHelpers(ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpHelperArgs.builder()
 *                 .address("2001:0:0:1::0")
 *                 .dhcpv6HelperVpn(1)
 *                 .build())
 *             .ipv4Nat(false)
 *             .ipv4NatRangeStart("1.2.3.4")
 *             .ipv4NatRangeEnd("4.5.6.7")
 *             .ipv4NatPrefixLength(1)
 *             .ipv4NatOverload(true)
 *             .ipv6Nat(true)
 *             .nat64(false)
 *             .aclShapingRate(12)
 *             .ipv6Vrrps(ServiceLanVpnInterfaceEthernetFeatureIpv6VrrpArgs.builder()
 *                 .groupId(1)
 *                 .priority(100)
 *                 .timer(1000)
 *                 .trackOmp(false)
 *                 .ipv6Addresses(ServiceLanVpnInterfaceEthernetFeatureIpv6VrrpIpv6AddressArgs.builder()
 *                     .linkLocalAddress("1::1")
 *                     .globalAddress("1::1/24")
 *                     .build())
 *                 .followDualRouterHighAvailability(false)
 *                 .minPreemptDelay(60)
 *                 .build())
 *             .ipv4Vrrps(ServiceLanVpnInterfaceEthernetFeatureIpv4VrrpArgs.builder()
 *                 .groupId(1)
 *                 .priority(100)
 *                 .timer(1000)
 *                 .trackOmp(false)
 *                 .address("1.2.3.4")
 *                 .secondaryAddresses(ServiceLanVpnInterfaceEthernetFeatureIpv4VrrpSecondaryAddressArgs.builder()
 *                     .address("2.3.4.5")
 *                     .subnetMask("0.0.0.0")
 *                     .build())
 *                 .tlocPrefixChange(true)
 *                 .tlocPrefChangeValue(100)
 *                 .trackingObjects(ServiceLanVpnInterfaceEthernetFeatureIpv4VrrpTrackingObjectArgs.builder()
 *                     .trackerId("1b270f6d-479b-47e3-ab0b-51bc6811a303")
 *                     .trackerAction("Decrement")
 *                     .decrementValue(100)
 *                     .build())
 *                 .followDualRouterHighAvailability(false)
 *                 .minPreemptDelay(60)
 *                 .build())
 *             .arps(ServiceLanVpnInterfaceEthernetFeatureArpArgs.builder()
 *                 .ipAddress("1.2.3.4")
 *                 .macAddress("00-B0-D0-63-C2-26")
 *                 .build())
 *             .trustsecEnableSgtPropogation(false)
 *             .trustsecPropogate(true)
 *             .trustsecSecurityGroupTag(123)
 *             .trustsecEnableEnforcedPropogation(false)
 *             .trustsecEnforcedSecurityGroupTag(1234)
 *             .duplex("full")
 *             .macAddress("00-B0-D0-63-C2-26")
 *             .ipMtu(1500)
 *             .interfaceMtu(1500)
 *             .tcpMss(500)
 *             .speed("1000")
 *             .arpTimeout(1200)
 *             .autonegotiate(false)
 *             .mediaType("auto-select")
 *             .loadInterval(30)
 *             .icmpRedirectDisable(true)
 *             .xconnect("1")
 *             .ipDirectedBroadcast(false)
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * The `pulumi import` command can be used, for example:
 * 
 * Expected import identifier with the format: &#34;service_lan_vpn_interface_ethernet_feature_id,feature_profile_id,service_lan_vpn_feature_id&#34;
 * 
 * ```sh
 * $ pulumi import sdwan:index/serviceLanVpnInterfaceEthernetFeature:ServiceLanVpnInterfaceEthernetFeature example &#34;f6b2c44c-693c-4763-b010-895aa3d236bd,f6dd22c8-0b4f-496c-9a0b-6813d1f8b8ac,140331f6-5418-4755-a059-13c77eb96037&#34;
 * ```
 * 
 */
@ResourceType(type="sdwan:index/serviceLanVpnInterfaceEthernetFeature:ServiceLanVpnInterfaceEthernetFeature")
public class ServiceLanVpnInterfaceEthernetFeature extends com.pulumi.resources.CustomResource {
    @Export(name="aclIpv4EgressPolicyId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv4EgressPolicyId;

    public Output<Optional<String>> aclIpv4EgressPolicyId() {
        return Codegen.optional(this.aclIpv4EgressPolicyId);
    }
    @Export(name="aclIpv4IngressPolicyId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv4IngressPolicyId;

    public Output<Optional<String>> aclIpv4IngressPolicyId() {
        return Codegen.optional(this.aclIpv4IngressPolicyId);
    }
    @Export(name="aclIpv6EgressPolicyId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv6EgressPolicyId;

    public Output<Optional<String>> aclIpv6EgressPolicyId() {
        return Codegen.optional(this.aclIpv6EgressPolicyId);
    }
    @Export(name="aclIpv6IngressPolicyId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclIpv6IngressPolicyId;

    public Output<Optional<String>> aclIpv6IngressPolicyId() {
        return Codegen.optional(this.aclIpv6IngressPolicyId);
    }
    /**
     * Shaping Rate (Kbps), Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `8`-`100000000`
     * 
     */
    @Export(name="aclShapingRate", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> aclShapingRate;

    /**
     * @return Shaping Rate (Kbps), Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `8`-`100000000`
     * 
     */
    public Output<Optional<Integer>> aclShapingRate() {
        return Codegen.optional(this.aclShapingRate);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="aclShapingRateVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> aclShapingRateVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> aclShapingRateVariable() {
        return Codegen.optional(this.aclShapingRateVariable);
    }
    /**
     * Timeout value for dynamically learned ARP entries, &lt;0..2678400&gt; seconds, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `0`-`2147483`
     *   - Default value: `1200`
     * 
     */
    @Export(name="arpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> arpTimeout;

    /**
     * @return Timeout value for dynamically learned ARP entries, &lt;0..2678400&gt; seconds, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `0`-`2147483`
     *   - Default value: `1200`
     * 
     */
    public Output<Optional<Integer>> arpTimeout() {
        return Codegen.optional(this.arpTimeout);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="arpTimeoutVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> arpTimeoutVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> arpTimeoutVariable() {
        return Codegen.optional(this.arpTimeoutVariable);
    }
    /**
     * Configure ARP entries, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="arps", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureArp.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureArp>> arps;

    /**
     * @return Configure ARP entries, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureArp>>> arps() {
        return Codegen.optional(this.arps);
    }
    /**
     * Link autonegotiation
     * 
     */
    @Export(name="autonegotiate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> autonegotiate;

    /**
     * @return Link autonegotiation
     * 
     */
    public Output<Optional<Boolean>> autonegotiate() {
        return Codegen.optional(this.autonegotiate);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="autonegotiateVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> autonegotiateVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> autonegotiateVariable() {
        return Codegen.optional(this.autonegotiateVariable);
    }
    /**
     * The description of the Feature
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of the Feature
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Duplex mode, Attribute conditional on `portChannelInterface` not equal to `true`
     *   - Choices: `full`, `half`, `auto`
     * 
     */
    @Export(name="duplex", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> duplex;

    /**
     * @return Duplex mode, Attribute conditional on `portChannelInterface` not equal to `true`
     *   - Choices: `full`, `half`, `auto`
     * 
     */
    public Output<Optional<String>> duplex() {
        return Codegen.optional(this.duplex);
    }
    /**
     * Variable name, Attribute conditional on `portChannelInterface` not equal to `true`
     * 
     */
    @Export(name="duplexVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> duplexVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> duplexVariable() {
        return Codegen.optional(this.duplexVariable);
    }
    /**
     * Enable DHCPv6, Attribute conditional on `ipv6ConfigurationType` equal to `dynamic`
     * 
     */
    @Export(name="enableDhcpv6", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> enableDhcpv6;

    /**
     * @return Enable DHCPv6, Attribute conditional on `ipv6ConfigurationType` equal to `dynamic`
     * 
     */
    public Output<Optional<Boolean>> enableDhcpv6() {
        return Codegen.optional(this.enableDhcpv6);
    }
    /**
     * Feature Profile ID
     * 
     */
    @Export(name="featureProfileId", refs={String.class}, tree="[0]")
    private Output<String> featureProfileId;

    /**
     * @return Feature Profile ID
     * 
     */
    public Output<String> featureProfileId() {
        return this.featureProfileId;
    }
    /**
     * ICMP/ICMPv6 Redirect Disable, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `true`
     * 
     */
    @Export(name="icmpRedirectDisable", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> icmpRedirectDisable;

    /**
     * @return ICMP/ICMPv6 Redirect Disable, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> icmpRedirectDisable() {
        return Codegen.optional(this.icmpRedirectDisable);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="icmpRedirectDisableVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> icmpRedirectDisableVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> icmpRedirectDisableVariable() {
        return Codegen.optional(this.icmpRedirectDisableVariable);
    }
    @Export(name="interfaceDescription", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceDescription;

    public Output<Optional<String>> interfaceDescription() {
        return Codegen.optional(this.interfaceDescription);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="interfaceDescriptionVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceDescriptionVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> interfaceDescriptionVariable() {
        return Codegen.optional(this.interfaceDescriptionVariable);
    }
    /**
     * Interface MTU, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `1500`-`9216`
     *   - Default value: `1500`
     * 
     */
    @Export(name="interfaceMtu", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> interfaceMtu;

    /**
     * @return Interface MTU, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `1500`-`9216`
     *   - Default value: `1500`
     * 
     */
    public Output<Optional<Integer>> interfaceMtu() {
        return Codegen.optional(this.interfaceMtu);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="interfaceMtuVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceMtuVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> interfaceMtuVariable() {
        return Codegen.optional(this.interfaceMtuVariable);
    }
    @Export(name="interfaceName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceName;

    public Output<Optional<String>> interfaceName() {
        return Codegen.optional(this.interfaceName);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="interfaceNameVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> interfaceNameVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> interfaceNameVariable() {
        return Codegen.optional(this.interfaceNameVariable);
    }
    /**
     * IP Directed-Broadcast, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="ipDirectedBroadcast", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ipDirectedBroadcast;

    /**
     * @return IP Directed-Broadcast, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> ipDirectedBroadcast() {
        return Codegen.optional(this.ipDirectedBroadcast);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="ipDirectedBroadcastVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipDirectedBroadcastVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> ipDirectedBroadcastVariable() {
        return Codegen.optional(this.ipDirectedBroadcastVariable);
    }
    /**
     * IP MTU for GigabitEthernet main &lt;576..Interface MTU&gt;, GigabitEthernet subinterface &lt;576..9216&gt;, Other Interfaces &lt;576..2000&gt; in bytes, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `576`-`9216`
     *   - Default value: `1500`
     * 
     */
    @Export(name="ipMtu", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipMtu;

    /**
     * @return IP MTU for GigabitEthernet main &lt;576..Interface MTU&gt;, GigabitEthernet subinterface &lt;576..9216&gt;, Other Interfaces &lt;576..2000&gt; in bytes, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `576`-`9216`
     *   - Default value: `1500`
     * 
     */
    public Output<Optional<Integer>> ipMtu() {
        return Codegen.optional(this.ipMtu);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="ipMtuVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipMtuVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> ipMtuVariable() {
        return Codegen.optional(this.ipMtuVariable);
    }
    /**
     * IP Address, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv4Address", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4Address;

    /**
     * @return IP Address, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<String>> ipv4Address() {
        return Codegen.optional(this.ipv4Address);
    }
    /**
     * Variable name, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv4AddressVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4AddressVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<String>> ipv4AddressVariable() {
        return Codegen.optional(this.ipv4AddressVariable);
    }
    /**
     * IPv4 Configuration Type, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Choices: `dynamic`, `static`, `none`
     *   - Default value: `dynamic`
     * 
     */
    @Export(name="ipv4ConfigurationType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4ConfigurationType;

    /**
     * @return IPv4 Configuration Type, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Choices: `dynamic`, `static`, `none`
     *   - Default value: `dynamic`
     * 
     */
    public Output<Optional<String>> ipv4ConfigurationType() {
        return Codegen.optional(this.ipv4ConfigurationType);
    }
    /**
     * DHCP Distance, Attribute conditional on `ipv4ConfigurationType` equal to `dynamic`
     *   - Range: `1`-`255`
     *   - Default value: `1`
     * 
     */
    @Export(name="ipv4DhcpDistance", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipv4DhcpDistance;

    /**
     * @return DHCP Distance, Attribute conditional on `ipv4ConfigurationType` equal to `dynamic`
     *   - Range: `1`-`255`
     *   - Default value: `1`
     * 
     */
    public Output<Optional<Integer>> ipv4DhcpDistance() {
        return Codegen.optional(this.ipv4DhcpDistance);
    }
    /**
     * Variable name, Attribute conditional on `ipv4ConfigurationType` equal to `dynamic`
     * 
     */
    @Export(name="ipv4DhcpDistanceVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4DhcpDistanceVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv4ConfigurationType` equal to `dynamic`
     * 
     */
    public Output<Optional<String>> ipv4DhcpDistanceVariable() {
        return Codegen.optional(this.ipv4DhcpDistanceVariable);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="ipv4DhcpHelperVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4DhcpHelperVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> ipv4DhcpHelperVariable() {
        return Codegen.optional(this.ipv4DhcpHelperVariable);
    }
    /**
     * List of DHCP IPv4 helper addresses (min 1, max 8), Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="ipv4DhcpHelpers", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> ipv4DhcpHelpers;

    /**
     * @return List of DHCP IPv4 helper addresses (min 1, max 8), Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<List<String>>> ipv4DhcpHelpers() {
        return Codegen.optional(this.ipv4DhcpHelpers);
    }
    /**
     * enable Network Address Translation on this interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="ipv4Nat", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ipv4Nat;

    /**
     * @return enable Network Address Translation on this interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> ipv4Nat() {
        return Codegen.optional(this.ipv4Nat);
    }
    /**
     * NAT Inside Source Loopback Interface
     * 
     */
    @Export(name="ipv4NatLoopback", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatLoopback;

    /**
     * @return NAT Inside Source Loopback Interface
     * 
     */
    public Output<Optional<String>> ipv4NatLoopback() {
        return Codegen.optional(this.ipv4NatLoopback);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatLoopbackVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatLoopbackVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatLoopbackVariable() {
        return Codegen.optional(this.ipv4NatLoopbackVariable);
    }
    /**
     * NAT Overload
     *   - Default value: `true`
     * 
     */
    @Export(name="ipv4NatOverload", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ipv4NatOverload;

    /**
     * @return NAT Overload
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> ipv4NatOverload() {
        return Codegen.optional(this.ipv4NatOverload);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatOverloadVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatOverloadVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatOverloadVariable() {
        return Codegen.optional(this.ipv4NatOverloadVariable);
    }
    /**
     * NAT Pool Prefix Length
     *   - Range: `1`-`32`
     * 
     */
    @Export(name="ipv4NatPrefixLength", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipv4NatPrefixLength;

    /**
     * @return NAT Pool Prefix Length
     *   - Range: `1`-`32`
     * 
     */
    public Output<Optional<Integer>> ipv4NatPrefixLength() {
        return Codegen.optional(this.ipv4NatPrefixLength);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatPrefixLengthVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatPrefixLengthVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatPrefixLengthVariable() {
        return Codegen.optional(this.ipv4NatPrefixLengthVariable);
    }
    /**
     * NAT Pool Range End
     * 
     */
    @Export(name="ipv4NatRangeEnd", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatRangeEnd;

    /**
     * @return NAT Pool Range End
     * 
     */
    public Output<Optional<String>> ipv4NatRangeEnd() {
        return Codegen.optional(this.ipv4NatRangeEnd);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatRangeEndVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatRangeEndVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatRangeEndVariable() {
        return Codegen.optional(this.ipv4NatRangeEndVariable);
    }
    /**
     * NAT Pool Range Start
     * 
     */
    @Export(name="ipv4NatRangeStart", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatRangeStart;

    /**
     * @return NAT Pool Range Start
     * 
     */
    public Output<Optional<String>> ipv4NatRangeStart() {
        return Codegen.optional(this.ipv4NatRangeStart);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatRangeStartVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatRangeStartVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatRangeStartVariable() {
        return Codegen.optional(this.ipv4NatRangeStartVariable);
    }
    /**
     * Set NAT TCP session timeout, in minutes
     *   - Range: `1`-`8947`
     *   - Default value: `60`
     * 
     */
    @Export(name="ipv4NatTcpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipv4NatTcpTimeout;

    /**
     * @return Set NAT TCP session timeout, in minutes
     *   - Range: `1`-`8947`
     *   - Default value: `60`
     * 
     */
    public Output<Optional<Integer>> ipv4NatTcpTimeout() {
        return Codegen.optional(this.ipv4NatTcpTimeout);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatTcpTimeoutVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatTcpTimeoutVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatTcpTimeoutVariable() {
        return Codegen.optional(this.ipv4NatTcpTimeoutVariable);
    }
    /**
     * Set NAT UDP session timeout, in minutes
     *   - Range: `1`-`8947`
     *   - Default value: `1`
     * 
     */
    @Export(name="ipv4NatUdpTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> ipv4NatUdpTimeout;

    /**
     * @return Set NAT UDP session timeout, in minutes
     *   - Range: `1`-`8947`
     *   - Default value: `1`
     * 
     */
    public Output<Optional<Integer>> ipv4NatUdpTimeout() {
        return Codegen.optional(this.ipv4NatUdpTimeout);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="ipv4NatUdpTimeoutVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4NatUdpTimeoutVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> ipv4NatUdpTimeoutVariable() {
        return Codegen.optional(this.ipv4NatUdpTimeoutVariable);
    }
    /**
     * Secondary IpV4 Addresses, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv4SecondaryAddresses", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureIpv4SecondaryAddress.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureIpv4SecondaryAddress>> ipv4SecondaryAddresses;

    /**
     * @return Secondary IpV4 Addresses, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureIpv4SecondaryAddress>>> ipv4SecondaryAddresses() {
        return Codegen.optional(this.ipv4SecondaryAddresses);
    }
    /**
     * Subnet Mask, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     *   - Choices: `255.255.255.255`, `255.255.255.254`, `255.255.255.252`, `255.255.255.248`, `255.255.255.240`, `255.255.255.224`, `255.255.255.192`, `255.255.255.128`, `255.255.255.0`, `255.255.254.0`, `255.255.252.0`, `255.255.248.0`, `255.255.240.0`, `255.255.224.0`, `255.255.192.0`, `255.255.128.0`, `255.255.0.0`, `255.254.0.0`, `255.252.0.0`, `255.240.0.0`, `255.224.0.0`, `255.192.0.0`, `255.128.0.0`, `255.0.0.0`, `254.0.0.0`, `252.0.0.0`, `248.0.0.0`, `240.0.0.0`, `224.0.0.0`, `192.0.0.0`, `128.0.0.0`, `0.0.0.0`
     * 
     */
    @Export(name="ipv4SubnetMask", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4SubnetMask;

    /**
     * @return Subnet Mask, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     *   - Choices: `255.255.255.255`, `255.255.255.254`, `255.255.255.252`, `255.255.255.248`, `255.255.255.240`, `255.255.255.224`, `255.255.255.192`, `255.255.255.128`, `255.255.255.0`, `255.255.254.0`, `255.255.252.0`, `255.255.248.0`, `255.255.240.0`, `255.255.224.0`, `255.255.192.0`, `255.255.128.0`, `255.255.0.0`, `255.254.0.0`, `255.252.0.0`, `255.240.0.0`, `255.224.0.0`, `255.192.0.0`, `255.128.0.0`, `255.0.0.0`, `254.0.0.0`, `252.0.0.0`, `248.0.0.0`, `240.0.0.0`, `224.0.0.0`, `192.0.0.0`, `128.0.0.0`, `0.0.0.0`
     * 
     */
    public Output<Optional<String>> ipv4SubnetMask() {
        return Codegen.optional(this.ipv4SubnetMask);
    }
    /**
     * Variable name, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv4SubnetMaskVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv4SubnetMaskVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv4ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<String>> ipv4SubnetMaskVariable() {
        return Codegen.optional(this.ipv4SubnetMaskVariable);
    }
    /**
     * Enable VRRP, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="ipv4Vrrps", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureIpv4Vrrp.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureIpv4Vrrp>> ipv4Vrrps;

    /**
     * @return Enable VRRP, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureIpv4Vrrp>>> ipv4Vrrps() {
        return Codegen.optional(this.ipv4Vrrps);
    }
    /**
     * IPv6 Address Secondary, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv6Address", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv6Address;

    /**
     * @return IPv6 Address Secondary, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<String>> ipv6Address() {
        return Codegen.optional(this.ipv6Address);
    }
    /**
     * Variable name, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv6AddressVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv6AddressVariable;

    /**
     * @return Variable name, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<String>> ipv6AddressVariable() {
        return Codegen.optional(this.ipv6AddressVariable);
    }
    /**
     * IPv6 Configuration Type, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Choices: `dynamic`, `static`, `none`
     *   - Default value: `none`
     * 
     */
    @Export(name="ipv6ConfigurationType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> ipv6ConfigurationType;

    /**
     * @return IPv6 Configuration Type, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Choices: `dynamic`, `static`, `none`
     *   - Default value: `none`
     * 
     */
    public Output<Optional<String>> ipv6ConfigurationType() {
        return Codegen.optional(this.ipv6ConfigurationType);
    }
    /**
     * DHCPv6 Helper, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv6DhcpHelpers", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpHelper.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpHelper>> ipv6DhcpHelpers;

    /**
     * @return DHCPv6 Helper, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpHelper>>> ipv6DhcpHelpers() {
        return Codegen.optional(this.ipv6DhcpHelpers);
    }
    /**
     * secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` equal to `dynamic`
     * 
     */
    @Export(name="ipv6DhcpSecondaryAddresses", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress>> ipv6DhcpSecondaryAddresses;

    /**
     * @return secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` equal to `dynamic`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureIpv6DhcpSecondaryAddress>>> ipv6DhcpSecondaryAddresses() {
        return Codegen.optional(this.ipv6DhcpSecondaryAddresses);
    }
    /**
     * enable Network Address Translation ipv6 on this interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="ipv6Nat", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> ipv6Nat;

    /**
     * @return enable Network Address Translation ipv6 on this interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> ipv6Nat() {
        return Codegen.optional(this.ipv6Nat);
    }
    /**
     * Static secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    @Export(name="ipv6SecondaryAddresses", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureIpv6SecondaryAddress.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureIpv6SecondaryAddress>> ipv6SecondaryAddresses;

    /**
     * @return Static secondary IPv6 addresses, Attribute conditional on `ipv6ConfigurationType` equal to `static`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureIpv6SecondaryAddress>>> ipv6SecondaryAddresses() {
        return Codegen.optional(this.ipv6SecondaryAddresses);
    }
    /**
     * Enable VRRP Ipv6, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="ipv6Vrrps", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureIpv6Vrrp.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureIpv6Vrrp>> ipv6Vrrps;

    /**
     * @return Enable VRRP Ipv6, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureIpv6Vrrp>>> ipv6Vrrps() {
        return Codegen.optional(this.ipv6Vrrps);
    }
    /**
     * Interval for interface load calculation
     *   - Range: `30`-`600`
     *   - Default value: `30`
     * 
     */
    @Export(name="loadInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> loadInterval;

    /**
     * @return Interval for interface load calculation
     *   - Range: `30`-`600`
     *   - Default value: `30`
     * 
     */
    public Output<Optional<Integer>> loadInterval() {
        return Codegen.optional(this.loadInterval);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="loadIntervalVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> loadIntervalVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> loadIntervalVariable() {
        return Codegen.optional(this.loadIntervalVariable);
    }
    /**
     * MAC Address, Attribute conditional on `portChannelMemberInterface` not equal to `true` and `portChannelInterface` not equal to `true`
     * 
     */
    @Export(name="macAddress", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> macAddress;

    /**
     * @return MAC Address, Attribute conditional on `portChannelMemberInterface` not equal to `true` and `portChannelInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> macAddress() {
        return Codegen.optional(this.macAddress);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true` and `portChannelInterface` not equal to `true`
     * 
     */
    @Export(name="macAddressVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> macAddressVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true` and `portChannelInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> macAddressVariable() {
        return Codegen.optional(this.macAddressVariable);
    }
    /**
     * Media type, Attribute conditional on `portChannelInterface` not equal to `true`
     *   - Choices: `auto-select`, `rj45`, `sfp`
     * 
     */
    @Export(name="mediaType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> mediaType;

    /**
     * @return Media type, Attribute conditional on `portChannelInterface` not equal to `true`
     *   - Choices: `auto-select`, `rj45`, `sfp`
     * 
     */
    public Output<Optional<String>> mediaType() {
        return Codegen.optional(this.mediaType);
    }
    /**
     * Variable name, Attribute conditional on `portChannelInterface` not equal to `true`
     * 
     */
    @Export(name="mediaTypeVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> mediaTypeVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> mediaTypeVariable() {
        return Codegen.optional(this.mediaTypeVariable);
    }
    /**
     * The name of the Feature
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the Feature
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * NAT64 on this interface
     *   - Default value: `false`
     * 
     */
    @Export(name="nat64", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> nat64;

    /**
     * @return NAT64 on this interface
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> nat64() {
        return Codegen.optional(this.nat64);
    }
    /**
     * Port-Channel interface on/off
     *   - Default value: `false`
     * 
     */
    @Export(name="portChannelInterface", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portChannelInterface;

    /**
     * @return Port-Channel interface on/off
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> portChannelInterface() {
        return Codegen.optional(this.portChannelInterface);
    }
    /**
     * Eanble lacp fast switchover, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpFastSwitchover", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portChannelLacpFastSwitchover;

    /**
     * @return Eanble lacp fast switchover, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<Boolean>> portChannelLacpFastSwitchover() {
        return Codegen.optional(this.portChannelLacpFastSwitchover);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpFastSwitchoverVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelLacpFastSwitchoverVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<String>> portChannelLacpFastSwitchoverVariable() {
        return Codegen.optional(this.portChannelLacpFastSwitchoverVariable);
    }
    /**
     * Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `lacp`
     *   - Choices: `flow`, `vlan`
     * 
     */
    @Export(name="portChannelLacpLoadBalance", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelLacpLoadBalance;

    /**
     * @return Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `lacp`
     *   - Choices: `flow`, `vlan`
     * 
     */
    public Output<Optional<String>> portChannelLacpLoadBalance() {
        return Codegen.optional(this.portChannelLacpLoadBalance);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpLoadBalanceVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelLacpLoadBalanceVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<String>> portChannelLacpLoadBalanceVariable() {
        return Codegen.optional(this.portChannelLacpLoadBalanceVariable);
    }
    /**
     * Set LACP max bundle, Attribute conditional on `portChannelMode` equal to `lacp`
     *   - Range: `1`-`16`
     * 
     */
    @Export(name="portChannelLacpMaxBundle", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> portChannelLacpMaxBundle;

    /**
     * @return Set LACP max bundle, Attribute conditional on `portChannelMode` equal to `lacp`
     *   - Range: `1`-`16`
     * 
     */
    public Output<Optional<Integer>> portChannelLacpMaxBundle() {
        return Codegen.optional(this.portChannelLacpMaxBundle);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpMaxBundleVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelLacpMaxBundleVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<String>> portChannelLacpMaxBundleVariable() {
        return Codegen.optional(this.portChannelLacpMaxBundleVariable);
    }
    /**
     * Configure Port-Channel member links, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpMemberLinks", refs={List.class,ServiceLanVpnInterfaceEthernetFeaturePortChannelLacpMemberLink.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeaturePortChannelLacpMemberLink>> portChannelLacpMemberLinks;

    /**
     * @return Configure Port-Channel member links, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeaturePortChannelLacpMemberLink>>> portChannelLacpMemberLinks() {
        return Codegen.optional(this.portChannelLacpMemberLinks);
    }
    /**
     * Set LACP min bundle, Attribute conditional on `portChannelMode` equal to `lacp`
     *   - Range: `1`-`16`
     * 
     */
    @Export(name="portChannelLacpMinBundle", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> portChannelLacpMinBundle;

    /**
     * @return Set LACP min bundle, Attribute conditional on `portChannelMode` equal to `lacp`
     *   - Range: `1`-`16`
     * 
     */
    public Output<Optional<Integer>> portChannelLacpMinBundle() {
        return Codegen.optional(this.portChannelLacpMinBundle);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpMinBundleVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelLacpMinBundleVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<String>> portChannelLacpMinBundleVariable() {
        return Codegen.optional(this.portChannelLacpMinBundleVariable);
    }
    /**
     * Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpQosAggregate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portChannelLacpQosAggregate;

    /**
     * @return Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<Boolean>> portChannelLacpQosAggregate() {
        return Codegen.optional(this.portChannelLacpQosAggregate);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    @Export(name="portChannelLacpQosAggregateVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelLacpQosAggregateVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `lacp`
     * 
     */
    public Output<Optional<String>> portChannelLacpQosAggregateVariable() {
        return Codegen.optional(this.portChannelLacpQosAggregateVariable);
    }
    /**
     * Port-Channel member interface on/off
     *   - Default value: `false`
     * 
     */
    @Export(name="portChannelMemberInterface", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portChannelMemberInterface;

    /**
     * @return Port-Channel member interface on/off
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> portChannelMemberInterface() {
        return Codegen.optional(this.portChannelMemberInterface);
    }
    /**
     * Port Channel Mode, Attribute conditional on `portChannelInterface` equal to `true`
     *   - Choices: `lacp`, `static`
     * 
     */
    @Export(name="portChannelMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelMode;

    /**
     * @return Port Channel Mode, Attribute conditional on `portChannelInterface` equal to `true`
     *   - Choices: `lacp`, `static`
     * 
     */
    public Output<Optional<String>> portChannelMode() {
        return Codegen.optional(this.portChannelMode);
    }
    /**
     * Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `static`
     *   - Choices: `flow`, `vlan`
     * 
     */
    @Export(name="portChannelStaticLoadBalance", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelStaticLoadBalance;

    /**
     * @return Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `static`
     *   - Choices: `flow`, `vlan`
     * 
     */
    public Output<Optional<String>> portChannelStaticLoadBalance() {
        return Codegen.optional(this.portChannelStaticLoadBalance);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    @Export(name="portChannelStaticLoadBalanceVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelStaticLoadBalanceVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    public Output<Optional<String>> portChannelStaticLoadBalanceVariable() {
        return Codegen.optional(this.portChannelStaticLoadBalanceVariable);
    }
    /**
     * Configure Port-Channel member links, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    @Export(name="portChannelStaticMemberLinks", refs={List.class,ServiceLanVpnInterfaceEthernetFeaturePortChannelStaticMemberLink.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeaturePortChannelStaticMemberLink>> portChannelStaticMemberLinks;

    /**
     * @return Configure Port-Channel member links, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeaturePortChannelStaticMemberLink>>> portChannelStaticMemberLinks() {
        return Codegen.optional(this.portChannelStaticMemberLinks);
    }
    /**
     * Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    @Export(name="portChannelStaticQosAggregate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portChannelStaticQosAggregate;

    /**
     * @return Enable QoS Port-Channel aggregate, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    public Output<Optional<Boolean>> portChannelStaticQosAggregate() {
        return Codegen.optional(this.portChannelStaticQosAggregate);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    @Export(name="portChannelStaticQosAggregateVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelStaticQosAggregateVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMode` equal to `static`
     * 
     */
    public Output<Optional<String>> portChannelStaticQosAggregateVariable() {
        return Codegen.optional(this.portChannelStaticQosAggregateVariable);
    }
    /**
     * Port Channel Sub Interface on/off, Attribute conditional on `portChannelInterface` equal to `true`
     * 
     */
    @Export(name="portChannelSubinterface", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> portChannelSubinterface;

    /**
     * @return Port Channel Sub Interface on/off, Attribute conditional on `portChannelInterface` equal to `true`
     * 
     */
    public Output<Optional<Boolean>> portChannelSubinterface() {
        return Codegen.optional(this.portChannelSubinterface);
    }
    /**
     * , Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    @Export(name="portChannelSubinterfacePrimaryInterfaceName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelSubinterfacePrimaryInterfaceName;

    /**
     * @return , Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    public Output<Optional<String>> portChannelSubinterfacePrimaryInterfaceName() {
        return Codegen.optional(this.portChannelSubinterfacePrimaryInterfaceName);
    }
    /**
     * Variable name, Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    @Export(name="portChannelSubinterfacePrimaryInterfaceNameVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelSubinterfacePrimaryInterfaceNameVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    public Output<Optional<String>> portChannelSubinterfacePrimaryInterfaceNameVariable() {
        return Codegen.optional(this.portChannelSubinterfacePrimaryInterfaceNameVariable);
    }
    /**
     * , Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    @Export(name="portChannelSubinterfaceSecondaryInterfaceName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelSubinterfaceSecondaryInterfaceName;

    /**
     * @return , Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    public Output<Optional<String>> portChannelSubinterfaceSecondaryInterfaceName() {
        return Codegen.optional(this.portChannelSubinterfaceSecondaryInterfaceName);
    }
    /**
     * Variable name, Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    @Export(name="portChannelSubinterfaceSecondaryInterfaceNameVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> portChannelSubinterfaceSecondaryInterfaceNameVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelInterface` equal to `true` and `portChannelSubinterface` equal to `true`
     * 
     */
    public Output<Optional<String>> portChannelSubinterfaceSecondaryInterfaceNameVariable() {
        return Codegen.optional(this.portChannelSubinterfaceSecondaryInterfaceNameVariable);
    }
    /**
     * Service LAN VPN Feature ID
     * 
     */
    @Export(name="serviceLanVpnFeatureId", refs={String.class}, tree="[0]")
    private Output<String> serviceLanVpnFeatureId;

    /**
     * @return Service LAN VPN Feature ID
     * 
     */
    public Output<String> serviceLanVpnFeatureId() {
        return this.serviceLanVpnFeatureId;
    }
    /**
     * - Default value: `true`
     * 
     */
    @Export(name="shutdown", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> shutdown;

    /**
     * @return - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> shutdown() {
        return Codegen.optional(this.shutdown);
    }
    /**
     * Variable name
     * 
     */
    @Export(name="shutdownVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> shutdownVariable;

    /**
     * @return Variable name
     * 
     */
    public Output<Optional<String>> shutdownVariable() {
        return Codegen.optional(this.shutdownVariable);
    }
    /**
     * Set interface speed, Attribute conditional on `portChannelInterface` not equal to `true`
     *   - Choices: `10`, `100`, `1000`, `2500`, `10000`, `25000`
     * 
     */
    @Export(name="speed", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> speed;

    /**
     * @return Set interface speed, Attribute conditional on `portChannelInterface` not equal to `true`
     *   - Choices: `10`, `100`, `1000`, `2500`, `10000`, `25000`
     * 
     */
    public Output<Optional<String>> speed() {
        return Codegen.optional(this.speed);
    }
    /**
     * Variable name, Attribute conditional on `portChannelInterface` not equal to `true`
     * 
     */
    @Export(name="speedVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> speedVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> speedVariable() {
        return Codegen.optional(this.speedVariable);
    }
    /**
     * static NAT
     * 
     */
    @Export(name="staticNats", refs={List.class,ServiceLanVpnInterfaceEthernetFeatureStaticNat.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ServiceLanVpnInterfaceEthernetFeatureStaticNat>> staticNats;

    /**
     * @return static NAT
     * 
     */
    public Output<Optional<List<ServiceLanVpnInterfaceEthernetFeatureStaticNat>>> staticNats() {
        return Codegen.optional(this.staticNats);
    }
    /**
     * TCP MSS on SYN packets, in bytes, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `500`-`1460`
     * 
     */
    @Export(name="tcpMss", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> tcpMss;

    /**
     * @return TCP MSS on SYN packets, in bytes, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `500`-`1460`
     * 
     */
    public Output<Optional<Integer>> tcpMss() {
        return Codegen.optional(this.tcpMss);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="tcpMssVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> tcpMssVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> tcpMssVariable() {
        return Codegen.optional(this.tcpMssVariable);
    }
    /**
     * Enable/Disable SGT Enforcement on an interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="trustsecEnableEnforcedPropogation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> trustsecEnableEnforcedPropogation;

    /**
     * @return Enable/Disable SGT Enforcement on an interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<Boolean>> trustsecEnableEnforcedPropogation() {
        return Codegen.optional(this.trustsecEnableEnforcedPropogation);
    }
    /**
     * Indicates that the interface is trustworthy for CTS, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    @Export(name="trustsecEnableSgtPropogation", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> trustsecEnableSgtPropogation;

    /**
     * @return Indicates that the interface is trustworthy for CTS, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `false`
     * 
     */
    public Output<Optional<Boolean>> trustsecEnableSgtPropogation() {
        return Codegen.optional(this.trustsecEnableSgtPropogation);
    }
    /**
     * SGT value between 2 and 65519, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `2`-`65519`
     * 
     */
    @Export(name="trustsecEnforcedSecurityGroupTag", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> trustsecEnforcedSecurityGroupTag;

    /**
     * @return SGT value between 2 and 65519, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `2`-`65519`
     * 
     */
    public Output<Optional<Integer>> trustsecEnforcedSecurityGroupTag() {
        return Codegen.optional(this.trustsecEnforcedSecurityGroupTag);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="trustsecEnforcedSecurityGroupTagVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> trustsecEnforcedSecurityGroupTagVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> trustsecEnforcedSecurityGroupTagVariable() {
        return Codegen.optional(this.trustsecEnforcedSecurityGroupTagVariable);
    }
    /**
     * Enables the interface for CTS SGT authorization and forwarding, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `true`
     * 
     */
    @Export(name="trustsecPropogate", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> trustsecPropogate;

    /**
     * @return Enables the interface for CTS SGT authorization and forwarding, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Default value: `true`
     * 
     */
    public Output<Optional<Boolean>> trustsecPropogate() {
        return Codegen.optional(this.trustsecPropogate);
    }
    /**
     * SGT value between 2 and 65519, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `2`-`65519`
     * 
     */
    @Export(name="trustsecSecurityGroupTag", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> trustsecSecurityGroupTag;

    /**
     * @return SGT value between 2 and 65519, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     *   - Range: `2`-`65519`
     * 
     */
    public Output<Optional<Integer>> trustsecSecurityGroupTag() {
        return Codegen.optional(this.trustsecSecurityGroupTag);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="trustsecSecurityGroupTagVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> trustsecSecurityGroupTagVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> trustsecSecurityGroupTagVariable() {
        return Codegen.optional(this.trustsecSecurityGroupTagVariable);
    }
    /**
     * The version of the Feature
     * 
     */
    @Export(name="version", refs={Integer.class}, tree="[0]")
    private Output<Integer> version;

    /**
     * @return The version of the Feature
     * 
     */
    public Output<Integer> version() {
        return this.version;
    }
    /**
     * Extend remote TLOC over a GRE tunnel to a local LAN interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="xconnect", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> xconnect;

    /**
     * @return Extend remote TLOC over a GRE tunnel to a local LAN interface, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> xconnect() {
        return Codegen.optional(this.xconnect);
    }
    /**
     * Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    @Export(name="xconnectVariable", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> xconnectVariable;

    /**
     * @return Variable name, Attribute conditional on `portChannelMemberInterface` not equal to `true`
     * 
     */
    public Output<Optional<String>> xconnectVariable() {
        return Codegen.optional(this.xconnectVariable);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ServiceLanVpnInterfaceEthernetFeature(java.lang.String name) {
        this(name, ServiceLanVpnInterfaceEthernetFeatureArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ServiceLanVpnInterfaceEthernetFeature(java.lang.String name, ServiceLanVpnInterfaceEthernetFeatureArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ServiceLanVpnInterfaceEthernetFeature(java.lang.String name, ServiceLanVpnInterfaceEthernetFeatureArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("sdwan:index/serviceLanVpnInterfaceEthernetFeature:ServiceLanVpnInterfaceEthernetFeature", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ServiceLanVpnInterfaceEthernetFeature(java.lang.String name, Output<java.lang.String> id, @Nullable ServiceLanVpnInterfaceEthernetFeatureState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("sdwan:index/serviceLanVpnInterfaceEthernetFeature:ServiceLanVpnInterfaceEthernetFeature", name, state, makeResourceOptions(options, id), false);
    }

    private static ServiceLanVpnInterfaceEthernetFeatureArgs makeArgs(ServiceLanVpnInterfaceEthernetFeatureArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ServiceLanVpnInterfaceEthernetFeatureArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ServiceLanVpnInterfaceEthernetFeature get(java.lang.String name, Output<java.lang.String> id, @Nullable ServiceLanVpnInterfaceEthernetFeatureState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ServiceLanVpnInterfaceEthernetFeature(name, id, state, options);
    }
}
